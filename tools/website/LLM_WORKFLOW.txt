# LLM Agent Workflow: Instruction System

## Complete GET-Only Pattern

### Session 1: Build & Save New Patch

1. **Understand task**
   - Parse user request
   - Identify target files

2. **Gather context (3-5 queries)**
   ```
   GET /mmsb/?format=json&_t=T1
   GET /mmsb/path/to/file.ext?_t=T2
   GET /mmsb/path/to/related?_t=T3
   ```

3. **Check existing instructions**
   ```
   GET /list-instructions?_t=T4
   ```
   - If matching instruction exists → skip to step 6

4. **Build patch preview**
   ```
   GET /build-patch?template=simple_replace&file=X&old_line=A&new_line=B&context_before=C&context_after=D&_t=T5
   ```
   - Review JSON response
   - Check patch_preview field

5. **Save if correct**
   ```
   GET /save-instruction?id=USER_TASK_001&file=X&template=simple_replace&old_line=A&new_line=B&context_before=C&context_after=D&purpose=Fix%20X&risk=low&_t=T6
   ```

6. **Apply instruction**
   ```
   GET /apply-instruction?id=USER_TASK_001&_t=T7
   ```

### Session 2+: Reuse Existing

1. **Check instructions**
   ```
   GET /list-instructions?_t=T1
   ```

2. **Review candidate**
   ```
   GET /instruction?id=USER_TASK_001&_t=T2
   ```

3. **Verify file state**
   ```
   GET /mmsb/path/to/file?_t=T3
   ```

4. **Apply**
   ```
   GET /apply-instruction?id=USER_TASK_001&_t=T4
   ```

## Template Reference

### simple_replace
```
?template=simple_replace
&file=path/file.ext
&old_line=text
&new_line=text
&context_before=line
&context_after=line
```

### add_cache_headers
```
?template=add_cache_headers
&file=path/file.js
&function=functionName
&old_line=res.writeHead(...)
&context_before=line
&context_after=line
```

### Direct mode (no template)
```
?file=path/file.ext
&line_before=old
&line_after=new
&context_1=ctx1
&context_2=ctx2
&context_3=ctx3
```

## Naming Convention

**Instruction IDs:**
- `USER_<TASK>_NNN` - User-requested changes
- `FIX_<BUG>_NNN` - Bug fixes
- `FEAT_<FEATURE>_NNN` - New features
- `REFACTOR_<AREA>_NNN` - Refactorings

## Error Recovery

**Build fails:**
- Re-fetch file with new timestamp
- Adjust context to match exact lines
- Retry build

**Apply fails:**
- Check if file changed since save
- Re-fetch and verify context
- Build new instruction if needed

**Instruction not found:**
- List all instructions
- Build new one

## Benefits

1. **Learning**: Successful patches persist
2. **Efficiency**: Future tasks reuse proven solutions
3. **Auditability**: All changes tracked by ID
4. **Determinism**: Same ID = identical execution
5. **Pure GET**: No POST/PUT/DELETE needed

## Example Complete Flow

```
User: "Fix the cache headers in file-server.js"

LLM:
1. GET /list-instructions → check for existing
2. Not found → proceed to build
3. GET /mmsb/tools/website/file-server.js → read current
4. GET /build-patch?template=add_cache_headers&file=file-server.js&function=handleDirectoryRequest&old_line=res.writeHead(200, { 'Content-Type': 'text/html' });
   → Review: looks good
5. GET /save-instruction?id=FIX_CACHE_001&[same params]&purpose=Add cache headers
   → Saved
6. GET /apply-instruction?id=FIX_CACHE_001
   → Success

User: "Do the same for handleFileRequest"

LLM:
1. GET /list-instructions → FIX_CACHE_001 exists
2. GET /instruction?id=FIX_CACHE_001 → review pattern
3. Build new: GET /save-instruction?id=FIX_CACHE_002&file=file-server.js&function=handleFileRequest&...
4. GET /apply-instruction?id=FIX_CACHE_002
   → Success
```

## Integration with MMSB

Instructions = persistent deltas
- Stored on "bus" (instructions/ directory)
- LLM selects, doesn't mutate
- Replay = GET /apply-instruction
- Audit = read index.json
