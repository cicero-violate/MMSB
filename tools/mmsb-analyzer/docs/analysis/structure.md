# MMSB Code Structure Analysis

Generated: 2025-12-16 13:43:23


## Layer: root

### Rust

- [Struct] `pub` **ControlFlowAnalyzer** @ ./src/control_flow.rs:0
- [Impl] `priv` **impl ControlFlowAnalyzer { pub fn new () -> Self { Self { graph : DiGraph :: new () , node_map : HashMap :: new () , } } pub fn build_call_graph (& mut self , result : & AnalysisResult) { for elem in & result . elements { if matches ! (elem . element_type , ElementType :: Function) { let node_name = format ! ("{}::{}" , elem . file_path , elem . name) ; let node_idx = self . graph . add_node (node_name . clone ()) ; self . node_map . insert (node_name , node_idx) ; } } for elem in & result . elements { if matches ! (elem . element_type , ElementType :: Function) { let caller_name = format ! ("{}::{}" , elem . file_path , elem . name) ; if let Some (& caller_idx) = self . node_map . get (& caller_name) { for called in & elem . calls { for target_elem in & result . elements { if matches ! (target_elem . element_type , ElementType :: Function) && (target_elem . name == * called || called . ends_with (& target_elem . name)) { let callee_name = format ! ("{}::{}" , target_elem . file_path , target_elem . name) ; if let Some (& callee_idx) = self . node_map . get (& callee_name) { self . graph . add_edge (caller_idx , callee_idx , called . clone ()) ; } } } } } } } } pub fn generate_dot (& self) -> String { format ! ("{:?}" , Dot :: new (& self . graph)) } pub fn generate_mermaid (& self) -> String { let mut output = String :: from ("```mermaid\ngraph TD\n") ; for node_idx in self . graph . node_indices () { let node_name = & self . graph [node_idx] ; let safe_name = node_name . replace ("::" , "_") . replace ("/" , "_") . replace ("." , "_") ; output . push_str (& format ! ("    {}[\"{}\"]\n" , safe_name , node_name)) ; } for edge in self . graph . edge_indices () { if let Some ((source , target)) = self . graph . edge_endpoints (edge) { let source_name = & self . graph [source] ; let target_name = & self . graph [target] ; let safe_source = source_name . replace ("::" , "_") . replace ("/" , "_") . replace ("." , "_") ; let safe_target = target_name . replace ("::" , "_") . replace ("/" , "_") . replace ("." , "_") ; output . push_str (& format ! ("    {} --> {}\n" , safe_source , safe_target)) ; } } output . push_str ("```\n") ; output } pub fn get_statistics (& self) -> CallGraphStats { let node_count = self . graph . node_count () ; let edge_count = self . graph . edge_count () ; let mut max_depth = 0 ; let mut leaf_functions = 0 ; for node_idx in self . graph . node_indices () { let outgoing = self . graph . edges (node_idx) . count () ; if outgoing == 0 { leaf_functions += 1 ; } let depth = self . calculate_depth (node_idx) ; if depth > max_depth { max_depth = depth ; } } CallGraphStats { total_functions : node_count , total_calls : edge_count , max_depth , leaf_functions , } } fn calculate_depth (& self , start : NodeIndex) -> usize { let mut visited = std :: collections :: HashSet :: new () ; self . dfs_depth (start , & mut visited) } fn dfs_depth (& self , node : NodeIndex , visited : & mut std :: collections :: HashSet < NodeIndex >) -> usize { if visited . contains (& node) { return 0 ; } visited . insert (node) ; let mut max = 0 ; for neighbor in self . graph . neighbors (node) { let depth = self . dfs_depth (neighbor , visited) ; if depth > max { max = depth ; } } visited . remove (& node) ; max + 1 } } . self_ty** @ ./src/control_flow.rs:0
- [Struct] `pub` **CallGraphStats** @ ./src/control_flow.rs:0
- [Struct] `pub` **JuliaAnalyzer** @ ./src/julia_parser.rs:0
- [Impl] `priv` **impl JuliaAnalyzer { pub fn new (root_path : String , script_path : String) -> Self { Self { root_path , script_path , } } pub fn analyze_file (& self , file_path : & Path) -> Result < AnalysisResult > { let output = Command :: new ("julia") . arg (& self . script_path) . arg (file_path) . output () . with_context (| | format ! ("Failed to execute Julia analyzer on {:?}" , file_path)) ? ; if ! output . status . success () { let stderr = String :: from_utf8_lossy (& output . stderr) ; anyhow :: bail ! ("Julia analyzer failed: {}" , stderr) ; } let stdout = String :: from_utf8_lossy (& output . stdout) ; let julia_elements : Vec < JuliaElement > = serde_json :: from_str (& stdout) . with_context (| | format ! ("Failed to parse Julia analyzer output: {}" , stdout)) ? ; let mut result = AnalysisResult :: new () ; let layer = self . extract_layer (file_path) ; for elem in julia_elements { let element_type = match elem . element_type . as_str () { "struct" => ElementType :: Struct , "function" => ElementType :: Function , "module" => ElementType :: Module , _ => continue , } ; result . add_element (CodeElement { element_type , name : elem . name , file_path : elem . file_path , line_number : elem . line_number , language : Language :: Julia , layer : layer . clone () , signature : elem . signature , calls : elem . calls , visibility : Visibility :: Public , generic_params : Vec :: new () , }) ; } Ok (result) } fn extract_layer (& self , path : & Path) -> String { for component in path . components () { if let Some (name) = component . as_os_str () . to_str () { if name . chars () . next () . map_or (false , | c | c . is_ascii_digit ()) { if let Some (pos) = name . find ('_') { if name [.. pos] . chars () . all (| c | c . is_ascii_digit ()) { return name . to_string () ; } } } } } "root" . to_string () } } . self_ty** @ ./src/julia_parser.rs:0
- [Module] `priv` **types** @ ./src/main.rs:0
- [Module] `priv` **rust_parser** @ ./src/main.rs:0
- [Module] `priv` **julia_parser** @ ./src/main.rs:0
- [Module] `priv` **control_flow** @ ./src/main.rs:0
- [Module] `priv` **report** @ ./src/main.rs:0
- [Struct] `priv` **Args** @ ./src/main.rs:0
- [Function] `priv` **main** @ ./src/main.rs:0
- [Struct] `pub` **ReportGenerator** @ ./src/report.rs:0
- [Impl] `priv` **impl ReportGenerator { pub fn new (output_dir : String) -> Self { Self { output_dir } } pub fn generate_all (& self , result : & AnalysisResult , cf_analyzer : & ControlFlowAnalyzer) -> Result < () > { fs :: create_dir_all (& self . output_dir) ? ; self . generate_structure_report (result) ? ; self . generate_control_flow_report (result , cf_analyzer) ? ; self . generate_module_dependencies (result) ? ; self . generate_function_analysis (result) ? ; Ok (()) } fn generate_structure_report (& self , result : & AnalysisResult) -> Result < () > { let path = Path :: new (& self . output_dir) . join ("structure.md") ; let mut content = String :: from ("# MMSB Code Structure Analysis\n\n") ; content . push_str (& format ! ("Generated: {}\n\n" , chrono :: Local :: now () . format ("%Y-%m-%d %H:%M:%S"))) ; let mut layers : HashMap < String , Vec < & CodeElement > > = HashMap :: new () ; for elem in & result . elements { layers . entry (elem . layer . clone ()) . or_insert_with (Vec :: new) . push (elem) ; } let mut sorted_layers : Vec < _ > = layers . keys () . collect () ; sorted_layers . sort () ; for layer in sorted_layers { content . push_str (& format ! ("\n## Layer: {}\n\n" , layer)) ; let elements = & layers [layer] ; let rust_elems : Vec < _ > = elements . iter () . filter (| e | matches ! (e . language , Language :: Rust)) . collect () ; let julia_elems : Vec < _ > = elements . iter () . filter (| e | matches ! (e . language , Language :: Julia)) . collect () ; if ! rust_elems . is_empty () { content . push_str ("### Rust\n\n") ; self . write_elements (& mut content , rust_elems) ; } if ! julia_elems . is_empty () { content . push_str ("\n### Julia\n\n") ; self . write_elements (& mut content , julia_elems) ; } } content . push_str ("\n## Summary Statistics\n\n") ; content . push_str (& format ! ("- Total elements: {}\n" , result . elements . len ())) ; content . push_str (& format ! ("- Rust elements: {}\n" , result . elements . iter () . filter (| e | matches ! (e . language , Language :: Rust)) . count ())) ; content . push_str (& format ! ("- Julia elements: {}\n" , result . elements . iter () . filter (| e | matches ! (e . language , Language :: Julia)) . count ())) ; let mut type_counts : HashMap < String , usize > = HashMap :: new () ; for elem in & result . elements { let key = format ! ("{:?}_{:?}" , elem . language , elem . element_type) ; * type_counts . entry (key) . or_insert (0) += 1 ; } content . push_str ("\n### By Type:\n\n") ; let mut sorted_types : Vec < _ > = type_counts . iter () . collect () ; sorted_types . sort_by_key (| (k , _) | k . as_str ()) ; for (type_name , count) in sorted_types { content . push_str (& format ! ("- {}: {}\n" , type_name , count)) ; } fs :: write (path , content) ? ; Ok (()) } fn write_elements (& self , content : & mut String , elements : Vec < & & CodeElement >) { let mut sorted = elements ; sorted . sort_by_key (| e | (& e . file_path , e . line_number)) ; for elem in sorted { let vis = match elem . visibility { Visibility :: Public => "pub" , Visibility :: Crate => "pub(crate)" , Visibility :: Private => "priv" , } ; content . push_str (& format ! ("- [{:?}] `{}` **{}** @ {}:{}\n" , elem . element_type , vis , elem . name , elem . file_path , elem . line_number)) ; } } fn generate_control_flow_report (& self , result : & AnalysisResult , cf_analyzer : & ControlFlowAnalyzer) -> Result < () > { let path = Path :: new (& self . output_dir) . join ("control_flow.md") ; let mut content = String :: from ("# Control Flow Analysis\n\n") ; let stats = cf_analyzer . get_statistics () ; content . push_str ("## Call Graph Statistics\n\n") ; content . push_str (& format ! ("- Total functions: {}\n" , stats . total_functions)) ; content . push_str (& format ! ("- Total function calls: {}\n" , stats . total_calls)) ; content . push_str (& format ! ("- Maximum call depth: {}\n" , stats . max_depth)) ; content . push_str (& format ! ("- Leaf functions (no outgoing calls): {}\n\n" , stats . leaf_functions)) ; content . push_str ("## Call Graph Visualization\n\n") ; content . push_str (& cf_analyzer . generate_mermaid ()) ; fs :: write (path , content) ? ; Ok (()) } fn generate_module_dependencies (& self , result : & AnalysisResult) -> Result < () > { let path = Path :: new (& self . output_dir) . join ("module_dependencies.md") ; let mut content = String :: from ("# Module Dependencies\n\n") ; let mut layer_modules : HashMap < String , Vec < & ModuleInfo > > = HashMap :: new () ; for module in & result . modules { layer_modules . entry (self . extract_layer_from_path (& module . file_path)) . or_insert_with (Vec :: new) . push (module) ; } for (layer , modules) in layer_modules { content . push_str (& format ! ("## Layer: {}\n\n" , layer)) ; for module in modules { content . push_str (& format ! ("### Module: `{}`\n\n" , module . name)) ; content . push_str (& format ! ("**File:** {}\n\n" , module . file_path)) ; if ! module . imports . is_empty () { content . push_str ("**Imports:**\n") ; for import in & module . imports { content . push_str (& format ! ("- `{}`\n" , import)) ; } content . push_str ("\n") ; } if ! module . submodules . is_empty () { content . push_str ("**Submodules:**\n") ; for submod in & module . submodules { content . push_str (& format ! ("- `{}`\n" , submod)) ; } content . push_str ("\n") ; } } } fs :: write (path , content) ? ; Ok (()) } fn generate_function_analysis (& self , result : & AnalysisResult) -> Result < () > { let path = Path :: new (& self . output_dir) . join ("function_analysis.md") ; let mut content = String :: from ("# Function Analysis\n\n") ; let functions : Vec < _ > = result . elements . iter () . filter (| e | matches ! (e . element_type , ElementType :: Function)) . collect () ; content . push_str (& format ! ("## Total Functions: {}\n\n" , functions . len ())) ; let mut layer_functions : HashMap < String , Vec < & CodeElement > > = HashMap :: new () ; for func in & functions { layer_functions . entry (func . layer . clone ()) . or_insert_with (Vec :: new) . push (func) ; } let mut sorted_layers : Vec < _ > = layer_functions . keys () . collect () ; sorted_layers . sort () ; for layer in sorted_layers { content . push_str (& format ! ("## Layer: {}\n\n" , layer)) ; let funcs = & layer_functions [layer] ; let mut rust_funcs : Vec < _ > = funcs . iter () . filter (| f | matches ! (f . language , Language :: Rust)) . collect () ; let mut julia_funcs : Vec < _ > = funcs . iter () . filter (| f | matches ! (f . language , Language :: Julia)) . collect () ; rust_funcs . sort_by_key (| f | & f . name) ; julia_funcs . sort_by_key (| f | & f . name) ; if ! rust_funcs . is_empty () { content . push_str ("### Rust Functions\n\n") ; for func in rust_funcs { content . push_str (& format ! ("#### `{}`\n\n" , func . name)) ; content . push_str (& format ! ("- **File:** {}:{}\n" , func . file_path , func . line_number)) ; content . push_str (& format ! ("- **Visibility:** {:?}\n" , func . visibility)) ; if ! func . generic_params . is_empty () { content . push_str (& format ! ("- **Generics:** {}\n" , func . generic_params . join (", "))) ; } if ! func . calls . is_empty () { content . push_str ("- **Calls:**\n") ; for call in & func . calls { content . push_str (& format ! ("  - `{}`\n" , call)) ; } } content . push_str ("\n") ; } } if ! julia_funcs . is_empty () { content . push_str ("### Julia Functions\n\n") ; for func in julia_funcs { content . push_str (& format ! ("#### `{}`\n\n" , func . name)) ; content . push_str (& format ! ("- **File:** {}:{}\n" , func . file_path , func . line_number)) ; content . push_str (& format ! ("- **Signature:** `{}`\n" , func . signature)) ; if ! func . calls . is_empty () { content . push_str ("- **Calls:**\n") ; for call in & func . calls { content . push_str (& format ! ("  - `{}`\n" , call)) ; } } content . push_str ("\n") ; } } } fs :: write (path , content) ? ; Ok (()) } fn extract_layer_from_path (& self , path : & str) -> String { for component in path . split ('/') { if component . chars () . next () . map_or (false , | c | c . is_ascii_digit ()) { if let Some (pos) = component . find ('_') { if component [.. pos] . chars () . all (| c | c . is_ascii_digit ()) { return component . to_string () ; } } } } "root" . to_string () } } . self_ty** @ ./src/report.rs:0
- [Struct] `pub` **RustAnalyzer** @ ./src/rust_parser.rs:0
- [Impl] `priv` **impl RustAnalyzer { pub fn new (root_path : String) -> Self { Self { root_path } } pub fn analyze_file (& self , file_path : & Path) -> Result < AnalysisResult > { let content = fs :: read_to_string (file_path) . with_context (| | format ! ("Failed to read file: {:?}" , file_path)) ? ; let syntax_tree = syn :: parse_file (& content) . with_context (| | format ! ("Failed to parse Rust file: {:?}" , file_path)) ? ; let mut result = AnalysisResult :: new () ; let layer = self . extract_layer (file_path) ; let file_path_str = file_path . to_string_lossy () . to_string () ; let mut visitor = RustVisitor { file_path : file_path_str . clone () , layer : layer . clone () , result : & mut result , } ; visitor . visit_file (& syntax_tree) ; Ok (result) } fn extract_layer (& self , path : & Path) -> String { for component in path . components () { if let Some (name) = component . as_os_str () . to_str () { if name . chars () . next () . map_or (false , | c | c . is_ascii_digit ()) { if let Some (pos) = name . find ('_') { if name [.. pos] . chars () . all (| c | c . is_ascii_digit ()) { return name . to_string () ; } } } } } "root" . to_string () } } . self_ty** @ ./src/rust_parser.rs:0
- [Struct] `priv` **RustVisitor** @ ./src/rust_parser.rs:0
- [Impl] `priv` **impl < 'a > RustVisitor < 'a > { fn get_visibility (& self , vis : & syn :: Visibility) -> Visibility { match vis { syn :: Visibility :: Public (_) => Visibility :: Public , syn :: Visibility :: Restricted (r) => { if let Some (first) = r . path . segments . first () { if first . ident == "crate" { return Visibility :: Crate ; } } Visibility :: Private } syn :: Visibility :: Inherited => Visibility :: Private , } } fn extract_function_calls (& self , block : & syn :: Block) -> Vec < String > { let mut calls = Vec :: new () ; struct CallVisitor < 'b > { calls : & 'b mut Vec < String > , } impl < 'b > Visit < '_ > for CallVisitor < 'b > { fn visit_expr_call (& mut self , node : & syn :: ExprCall) { if let syn :: Expr :: Path (path_expr) = & * node . func { let name = path_expr . path . segments . iter () . map (| s | s . ident . to_string ()) . collect :: < Vec < _ > > () . join ("::") ; self . calls . push (name) ; } syn :: visit :: visit_expr_call (self , node) ; } fn visit_expr_method_call (& mut self , node : & syn :: ExprMethodCall) { self . calls . push (node . method . to_string ()) ; syn :: visit :: visit_expr_method_call (self , node) ; } } let mut call_visitor = CallVisitor { calls : & mut calls } ; call_visitor . visit_block (block) ; calls } } . self_ty** @ ./src/rust_parser.rs:0
- [Struct] `priv` **CallVisitor** @ ./src/rust_parser.rs:0
- [Impl] `priv` **Visit for impl < 'b > Visit < '_ > for CallVisitor < 'b > { fn visit_expr_call (& mut self , node : & syn :: ExprCall) { if let syn :: Expr :: Path (path_expr) = & * node . func { let name = path_expr . path . segments . iter () . map (| s | s . ident . to_string ()) . collect :: < Vec < _ > > () . join ("::") ; self . calls . push (name) ; } syn :: visit :: visit_expr_call (self , node) ; } fn visit_expr_method_call (& mut self , node : & syn :: ExprMethodCall) { self . calls . push (node . method . to_string ()) ; syn :: visit :: visit_expr_method_call (self , node) ; } } . self_ty** @ ./src/rust_parser.rs:0
- [Impl] `priv` **Visit for impl < 'a > Visit < '_ > for RustVisitor < 'a > { fn visit_item_struct (& mut self , node : & ItemStruct) { let generic_params = node . generics . params . iter () . filter_map (| p | match p { syn :: GenericParam :: Type (t) => Some (t . ident . to_string ()) , syn :: GenericParam :: Lifetime (l) => Some (l . lifetime . to_string ()) , _ => None , }) . collect () ; self . result . add_element (CodeElement { element_type : ElementType :: Struct , name : node . ident . to_string () , file_path : self . file_path . clone () , line_number : 0 , language : Language :: Rust , layer : self . layer . clone () , signature : quote :: quote ! (# node) . to_string () , calls : Vec :: new () , visibility : self . get_visibility (& node . vis) , generic_params , }) ; syn :: visit :: visit_item_struct (self , node) ; } fn visit_item_enum (& mut self , node : & ItemEnum) { let generic_params = node . generics . params . iter () . filter_map (| p | match p { syn :: GenericParam :: Type (t) => Some (t . ident . to_string ()) , _ => None , }) . collect () ; self . result . add_element (CodeElement { element_type : ElementType :: Enum , name : node . ident . to_string () , file_path : self . file_path . clone () , line_number : 0 , language : Language :: Rust , layer : self . layer . clone () , signature : format ! ("enum {}" , node . ident) , calls : Vec :: new () , visibility : self . get_visibility (& node . vis) , generic_params , }) ; syn :: visit :: visit_item_enum (self , node) ; } fn visit_item_trait (& mut self , node : & ItemTrait) { self . result . add_element (CodeElement { element_type : ElementType :: Trait , name : node . ident . to_string () , file_path : self . file_path . clone () , line_number : 0 , language : Language :: Rust , layer : self . layer . clone () , signature : format ! ("trait {}" , node . ident) , calls : Vec :: new () , visibility : self . get_visibility (& node . vis) , generic_params : Vec :: new () , }) ; syn :: visit :: visit_item_trait (self , node) ; } fn visit_item_impl (& mut self , node : & ItemImpl) { let impl_name = if let Some ((_ , path , _)) = & node . trait_ { format ! ("{} for {}" , path . segments . last () . unwrap () . ident , quote :: quote ! (# node . self_ty)) } else { quote :: quote ! (# node . self_ty) . to_string () } ; self . result . add_element (CodeElement { element_type : ElementType :: Impl , name : impl_name , file_path : self . file_path . clone () , line_number : 0 , language : Language :: Rust , layer : self . layer . clone () , signature : quote :: quote ! (# node) . to_string () , calls : Vec :: new () , visibility : Visibility :: Private , generic_params : Vec :: new () , }) ; syn :: visit :: visit_item_impl (self , node) ; } fn visit_item_fn (& mut self , node : & ItemFn) { let calls = self . extract_function_calls (& node . block) ; let generic_params = node . sig . generics . params . iter () . filter_map (| p | match p { syn :: GenericParam :: Type (t) => Some (t . ident . to_string ()) , syn :: GenericParam :: Lifetime (l) => Some (l . lifetime . to_string ()) , _ => None , }) . collect () ; self . result . add_element (CodeElement { element_type : ElementType :: Function , name : node . sig . ident . to_string () , file_path : self . file_path . clone () , line_number : 0 , language : Language :: Rust , layer : self . layer . clone () , signature : quote :: quote ! (# node . sig) . to_string () , calls , visibility : self . get_visibility (& node . vis) , generic_params , }) ; syn :: visit :: visit_item_fn (self , node) ; } fn visit_item_mod (& mut self , node : & ItemMod) { self . result . add_element (CodeElement { element_type : ElementType :: Module , name : node . ident . to_string () , file_path : self . file_path . clone () , line_number : 0 , language : Language :: Rust , layer : self . layer . clone () , signature : format ! ("mod {}" , node . ident) , calls : Vec :: new () , visibility : self . get_visibility (& node . vis) , generic_params : Vec :: new () , }) ; syn :: visit :: visit_item_mod (self , node) ; } } . self_ty** @ ./src/rust_parser.rs:0
- [Enum] `pub` **Language** @ ./src/types.rs:0
- [Enum] `pub` **ElementType** @ ./src/types.rs:0
- [Struct] `pub` **CodeElement** @ ./src/types.rs:0
- [Enum] `pub` **Visibility** @ ./src/types.rs:0
- [Struct] `pub` **ModuleInfo** @ ./src/types.rs:0
- [Struct] `pub` **CallGraphNode** @ ./src/types.rs:0
- [Struct] `pub` **AnalysisResult** @ ./src/types.rs:0
- [Impl] `priv` **impl AnalysisResult { pub fn new () -> Self { Self { elements : Vec :: new () , modules : Vec :: new () , call_graph : HashMap :: new () , type_hierarchy : HashMap :: new () , } } pub fn add_element (& mut self , element : CodeElement) { self . elements . push (element) ; } pub fn add_module (& mut self , module : ModuleInfo) { self . modules . push (module) ; } pub fn merge (& mut self , other : AnalysisResult) { self . elements . extend (other . elements) ; self . modules . extend (other . modules) ; self . call_graph . extend (other . call_graph) ; for (key , mut values) in other . type_hierarchy { self . type_hierarchy . entry (key) . or_insert_with (Vec :: new) . append (& mut values) ; } } } . self_ty** @ ./src/types.rs:0
- [Struct] `pub` **JuliaElement** @ ./src/types.rs:0

## Summary Statistics

- Total elements: 30
- Rust elements: 30
- Julia elements: 0

### By Type:

- Rust_Enum: 3
- Rust_Function: 1
- Rust_Impl: 8
- Rust_Module: 5
- Rust_Struct: 13
