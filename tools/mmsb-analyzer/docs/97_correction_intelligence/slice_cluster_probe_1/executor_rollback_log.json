{
  "version": "1.0",
  "timestamp": "2026-01-01T04:05:50.353145444+00:00",
  "actions": [
    {
      "action_id": "move_action_function_to_src/640_correction_intelligence_report.rs",
      "mutations": [
        {
          "type": "FileEdit",
          "path": "tools/mmsb-analyzer/src/570_correction_plan_generator.rs",
          "original_content": "#![allow(dead_code)]\n//! Generate correction plans from predictions.\n\nuse crate::correction_plan_types::{\n    CorrectionPlan, CorrectionStrategy, ErrorTier, RefactorAction, ViolationPrediction,\n    ViolationType, VisibilityPlanOption,\n};\nuse crate::tier_classifier::classify_tier;\n\npub fn generate_correction_plan(\n    action: &RefactorAction,\n    predictions: &[ViolationPrediction],\n) -> CorrectionPlan {\n    let mut strategies = Vec::new();\n    for prediction in predictions {\n        match prediction.violation_type {\n            ViolationType::UnresolvedImport => {\n                if let Some(symbol) = action_symbol(action) {\n                    strategies.push(CorrectionStrategy::AddImport {\n                        module_path: action_module_path(action),\n                        symbol,\n                    });\n                }\n            }\n            ViolationType::BrokenReference => {\n                match action {\n                    RefactorAction::RenameFile { .. } => {\n                        if let Some((old_ref, new_ref)) = action_refs(action) {\n                            strategies.push(CorrectionStrategy::UpdatePath {\n                                old_path: old_ref,\n                                new_path: new_ref,\n                            });\n                        }\n                    }\n                    _ => {\n                        if let Some((old_ref, new_ref)) = action_refs(action) {\n                            for file in &prediction.affected_files {\n                                strategies.push(CorrectionStrategy::UpdateCaller {\n                                    caller_file: file.clone(),\n                                    old_ref: old_ref.clone(),\n                                    new_ref: new_ref.clone(),\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            ViolationType::NameCollision => {\n                if let Some(symbol) = action_symbol(action) {\n                    strategies.push(CorrectionStrategy::RenameWithSuffix {\n                        original: symbol,\n                        suffix: \"_v2\".to_string(),\n                    });\n                }\n            }\n            ViolationType::LayerViolation => {\n                if let Some(layer) = action_target_layer(action) {\n                    if let Some(function) = action_function(action) {\n                        strategies.push(CorrectionStrategy::MoveToLayer {\n                            function,\n                            target_layer: layer,\n                        });\n                        if let Some(function) = action_function(action) {\n                            if let Some(layer) = action_target_layer(action) {\n                                strategies.push(CorrectionStrategy::EnsureImports {\n                                    function,\n                                    target_layer: layer,\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            ViolationType::VisibilityMismatch => {\n                if let Some((symbol, file, from, to, reason)) = action_visibility(action) {\n                    if from == to || reason.starts_with(\"review:\") {\n                        let options = vec![\n                            VisibilityPlanOption {\n                                policy: \"keep_public\".to_string(),\n                                target: crate::types::Visibility::Public,\n                                requires_consent: false,\n                                description: \"Keep public (treat as external API).\".to_string(),\n                            },\n                            VisibilityPlanOption {\n                                policy: \"downgrade_pub_crate\".to_string(),\n                                target: crate::types::Visibility::Crate,\n                                requires_consent: true,\n                                description:\n                                    \"Narrow to pub(crate) (internal API only).\".to_string(),\n                            },\n                            VisibilityPlanOption {\n                                policy: \"downgrade_private\".to_string(),\n                                target: crate::types::Visibility::Private,\n                                requires_consent: true,\n                                description: \"Narrow to private (file-local).\".to_string(),\n                            },\n                        ];\n                        strategies.push(CorrectionStrategy::VisibilityPlan {\n                            symbol,\n                            file,\n                            current: from,\n                            default_policy: \"review_only\".to_string(),\n                            options,\n                            notes: reason,\n                        });\n                    } else {\n                        strategies.push(CorrectionStrategy::AdjustVisibility {\n                            symbol,\n                            file,\n                            from,\n                            to,\n                            reason,\n                        });\n                    }\n                }\n            }\n            ViolationType::TypeMismatch | ViolationType::OwnershipIssue => {\n                strategies.push(CorrectionStrategy::ManualReview {\n                    reason: format!(\"{:?} requires semantic analysis\", prediction.violation_type),\n                    context: format!(\"{:?}\", action),\n                });\n            }\n        }\n    }\n\n    let tier = predictions\n        .iter()\n        .map(classify_tier)\n        .max()\n        .unwrap_or(ErrorTier::Trivial);\n\n    CorrectionPlan {\n        action_id: action.action_id(),\n        tier,\n        predicted_violations: predictions.to_vec(),\n        strategies,\n        confidence: average_confidence(predictions),\n        estimated_fix_time_seconds: estimate_fix_time(predictions.len()),\n    }\n}\n\nfn average_confidence(predictions: &[ViolationPrediction]) -> f64 {\n    if predictions.is_empty() {\n        return 1.0;\n    }\n    let total: f64 = predictions.iter().map(|p| p.confidence).sum();\n    total / predictions.len() as f64\n}\n\nfn estimate_fix_time(count: usize) -> u32 {\n    10 + (count as u32 * 5)\n}\n\nfn action_symbol(action: &RefactorAction) -> Option<String> {\n    match action {\n        RefactorAction::MoveFunction { function, .. } => Some(function.clone()),\n        RefactorAction::RenameFunction { new_name, .. } => Some(new_name.clone()),\n        RefactorAction::AdjustVisibility { symbol, .. } => Some(symbol.clone()),\n        _ => None,\n    }\n}\n\nfn action_function(action: &RefactorAction) -> Option<String> {\n    match action {\n        RefactorAction::MoveFunction { function, .. } => Some(function.clone()),\n        _ => None,\n    }\n}\n\nfn action_module_path(action: &RefactorAction) -> String {\n    match action {\n        RefactorAction::MoveFunction { to, .. } => to.display().to_string(),\n        RefactorAction::RenameFile { to, .. } => to.display().to_string(),\n        RefactorAction::CreateFile { path } => path.display().to_string(),\n        RefactorAction::AdjustVisibility { file, .. } => file.display().to_string(),\n        _ => \"crate\".to_string(),\n    }\n}\n\nfn action_refs(action: &RefactorAction) -> Option<(String, String)> {\n    match action {\n        RefactorAction::RenameFunction { old_name, new_name, .. } => {\n            Some((old_name.clone(), new_name.clone()))\n        }\n        RefactorAction::RenameFile { from, to } => {\n            Some((from.display().to_string(), to.display().to_string()))\n        }\n        _ => None,\n    }\n}\n\nfn action_target_layer(action: &RefactorAction) -> Option<String> {\n    match action {\n        RefactorAction::MoveFunction { required_layer, .. } => required_layer.clone(),\n        _ => None,\n    }\n}\n\nfn action_visibility(\n    action: &RefactorAction,\n) -> Option<(\n    String,\n    std::path::PathBuf,\n    crate::types::Visibility,\n    crate::types::Visibility,\n    String,\n)> {\n    match action {\n        RefactorAction::AdjustVisibility {\n            symbol,\n            file,\n            from,\n            to,\n            reason,\n        } => Some((symbol.clone(), file.clone(), from.clone(), to.clone(), reason.clone())),\n        _ => None,\n    }\n}\n",
          "updated_content": "#![allow(dead_code)]\n//! Generate correction plans from predictions.\n\nuse crate::correction_plan_types::{\n    CorrectionPlan, CorrectionStrategy, ErrorTier, RefactorAction, ViolationPrediction,\n    ViolationType, VisibilityPlanOption,\n};\nuse crate::tier_classifier::classify_tier;\nuse crate::correction_intelligence_report::action_function;\n\npub fn generate_correction_plan(\n    action: &RefactorAction,\n    predictions: &[ViolationPrediction],\n) -> CorrectionPlan {\n    let mut strategies = Vec::new();\n    for prediction in predictions {\n        match prediction.violation_type {\n            ViolationType::UnresolvedImport => {\n                if let Some(symbol) = action_symbol(action) {\n                    strategies.push(CorrectionStrategy::AddImport {\n                        module_path: action_module_path(action),\n                        symbol,\n                    });\n                }\n            }\n            ViolationType::BrokenReference => {\n                match action {\n                    RefactorAction::RenameFile { .. } => {\n                        if let Some((old_ref, new_ref)) = action_refs(action) {\n                            strategies.push(CorrectionStrategy::UpdatePath {\n                                old_path: old_ref,\n                                new_path: new_ref,\n                            });\n                        }\n                    }\n                    _ => {\n                        if let Some((old_ref, new_ref)) = action_refs(action) {\n                            for file in &prediction.affected_files {\n                                strategies.push(CorrectionStrategy::UpdateCaller {\n                                    caller_file: file.clone(),\n                                    old_ref: old_ref.clone(),\n                                    new_ref: new_ref.clone(),\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            ViolationType::NameCollision => {\n                if let Some(symbol) = action_symbol(action) {\n                    strategies.push(CorrectionStrategy::RenameWithSuffix {\n                        original: symbol,\n                        suffix: \"_v2\".to_string(),\n                    });\n                }\n            }\n            ViolationType::LayerViolation => {\n                if let Some(layer) = action_target_layer(action) {\n                    if let Some(function) = action_function(action) {\n                        strategies.push(CorrectionStrategy::MoveToLayer {\n                            function,\n                            target_layer: layer,\n                        });\n                        if let Some(function) = action_function(action) {\n                            if let Some(layer) = action_target_layer(action) {\n                                strategies.push(CorrectionStrategy::EnsureImports {\n                                    function,\n                                    target_layer: layer,\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            ViolationType::VisibilityMismatch => {\n                if let Some((symbol, file, from, to, reason)) = action_visibility(action) {\n                    if from == to || reason.starts_with(\"review:\") {\n                        let options = vec![\n                            VisibilityPlanOption {\n                                policy: \"keep_public\".to_string(),\n                                target: crate::types::Visibility::Public,\n                                requires_consent: false,\n                                description: \"Keep public (treat as external API).\".to_string(),\n                            },\n                            VisibilityPlanOption {\n                                policy: \"downgrade_pub_crate\".to_string(),\n                                target: crate::types::Visibility::Crate,\n                                requires_consent: true,\n                                description:\n                                    \"Narrow to pub(crate) (internal API only).\".to_string(),\n                            },\n                            VisibilityPlanOption {\n                                policy: \"downgrade_private\".to_string(),\n                                target: crate::types::Visibility::Private,\n                                requires_consent: true,\n                                description: \"Narrow to private (file-local).\".to_string(),\n                            },\n                        ];\n                        strategies.push(CorrectionStrategy::VisibilityPlan {\n                            symbol,\n                            file,\n                            current: from,\n                            default_policy: \"review_only\".to_string(),\n                            options,\n                            notes: reason,\n                        });\n                    } else {\n                        strategies.push(CorrectionStrategy::AdjustVisibility {\n                            symbol,\n                            file,\n                            from,\n                            to,\n                            reason,\n                        });\n                    }\n                }\n            }\n            ViolationType::TypeMismatch | ViolationType::OwnershipIssue => {\n                strategies.push(CorrectionStrategy::ManualReview {\n                    reason: format!(\"{:?} requires semantic analysis\", prediction.violation_type),\n                    context: format!(\"{:?}\", action),\n                });\n            }\n        }\n    }\n\n    let tier = predictions\n        .iter()\n        .map(classify_tier)\n        .max()\n        .unwrap_or(ErrorTier::Trivial);\n\n    CorrectionPlan {\n        action_id: action.action_id(),\n        tier,\n        predicted_violations: predictions.to_vec(),\n        strategies,\n        confidence: average_confidence(predictions),\n        estimated_fix_time_seconds: estimate_fix_time(predictions.len()),\n    }\n}\n\nfn average_confidence(predictions: &[ViolationPrediction]) -> f64 {\n    if predictions.is_empty() {\n        return 1.0;\n    }\n    let total: f64 = predictions.iter().map(|p| p.confidence).sum();\n    total / predictions.len() as f64\n}\n\nfn estimate_fix_time(count: usize) -> u32 {\n    10 + (count as u32 * 5)\n}\n\nfn action_symbol(action: &RefactorAction) -> Option<String> {\n    match action {\n        RefactorAction::MoveFunction { function, .. } => Some(function.clone()),\n        RefactorAction::RenameFunction { new_name, .. } => Some(new_name.clone()),\n        RefactorAction::AdjustVisibility { symbol, .. } => Some(symbol.clone()),\n        _ => None,\n    }\n}\n\n\n\nfn action_module_path(action: &RefactorAction) -> String {\n    match action {\n        RefactorAction::MoveFunction { to, .. } => to.display().to_string(),\n        RefactorAction::RenameFile { to, .. } => to.display().to_string(),\n        RefactorAction::CreateFile { path } => path.display().to_string(),\n        RefactorAction::AdjustVisibility { file, .. } => file.display().to_string(),\n        _ => \"crate\".to_string(),\n    }\n}\n\nfn action_refs(action: &RefactorAction) -> Option<(String, String)> {\n    match action {\n        RefactorAction::RenameFunction { old_name, new_name, .. } => {\n            Some((old_name.clone(), new_name.clone()))\n        }\n        RefactorAction::RenameFile { from, to } => {\n            Some((from.display().to_string(), to.display().to_string()))\n        }\n        _ => None,\n    }\n}\n\nfn action_target_layer(action: &RefactorAction) -> Option<String> {\n    match action {\n        RefactorAction::MoveFunction { required_layer, .. } => required_layer.clone(),\n        _ => None,\n    }\n}\n\nfn action_visibility(\n    action: &RefactorAction,\n) -> Option<(\n    String,\n    std::path::PathBuf,\n    crate::types::Visibility,\n    crate::types::Visibility,\n    String,\n)> {\n    match action {\n        RefactorAction::AdjustVisibility {\n            symbol,\n            file,\n            from,\n            to,\n            reason,\n        } => Some((symbol.clone(), file.clone(), from.clone(), to.clone(), reason.clone())),\n        _ => None,\n    }\n}\n"
        },
        {
          "type": "FileEdit",
          "path": "tools/mmsb-analyzer/src/640_correction_intelligence_report.rs",
          "original_content": "#![allow(dead_code)]\n//! Correction intelligence report generator.\n\nuse crate::correction_plan_types::{\n    CorrectionPlan, CorrectionStrategy, ErrorTier, RefactorAction, Severity, ViolationPrediction,\n    ViolationType,\n};\nuse crate::quality_delta_calculator::Metrics;\nuse crate::quality_delta_types::{QualityDelta, RollbackCriteria};\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse std::{collections::HashSet, fs};\n\nuse crate::invariant_types::InvariantAnalysisResult;\nuse crate::types::{AnalysisResult, CallGraphNode, CodeElement};\n\npub use crate::correction_plan_serializer::write_intelligence_outputs_at;\npub use crate::violation_predictor::generate_intelligence_report;\nuse crate::{\n    correction_plan_generator::generate_correction_plan,\n    rollback_criteria_builder::build_rollback_criteria,\n    verification_scope_planner::plan_verification_scope,\n};\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct CorrectionIntelligenceReport {\n    pub version: String,\n    pub timestamp: String,\n    pub project_root: PathBuf,\n    pub actions_analyzed: usize,\n    pub correction_plans: Vec<CorrectionPlan>,\n    pub verification_policies: Vec<crate::verification_policy_types::VerificationPolicy>,\n    pub rollback_criteria: Vec<RollbackCriteria>,\n    pub quality_deltas: Vec<QualityDelta>,\n    pub summary: CorrectionSummary,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct CorrectionSummary {\n    pub trivial_count: usize,\n    pub moderate_count: usize,\n    pub complex_count: usize,\n    pub total_predicted_violations: usize,\n    pub average_confidence: f64,\n    pub estimated_total_fix_time_seconds: u32,\n}\n\n#[derive(Clone, Debug)]\npub struct IntelligenceState<'a> {\n    pub root: PathBuf,\n    pub invariants: &'a InvariantAnalysisResult,\n    pub call_graph: &'a HashMap<String, CallGraphNode>,\n    pub elements: &'a [CodeElement],\n    pub metrics: Metrics,\n}\n\npub fn build_state<'a>(\n    root: &'a Path,\n    analysis: &'a AnalysisResult,\n    metrics: Metrics,\n) -> IntelligenceState<'a> {\n    IntelligenceState {\n        root: root.to_path_buf(),\n        invariants: &analysis.invariants,\n        call_graph: &analysis.call_graph,\n        elements: &analysis.elements,\n        metrics,\n    }\n}\n\n\n\npub fn write_intelligence_outputs(\n    report: &CorrectionIntelligenceReport,\n    output_dir: &Path,\n) -> std::io::Result<()> {\n    write_intelligence_outputs_at(report, output_dir, None, None)\n}\n\npub fn filter_path_coherence_report(\n    report: &CorrectionIntelligenceReport,\n) -> CorrectionIntelligenceReport {\n    let mut plans = Vec::new();\n    let mut policies = Vec::new();\n    let mut criteria = Vec::new();\n    let mut deltas = Vec::new();\n\n    for (idx, plan) in report.correction_plans.iter().enumerate() {\n        let mut has_path_coherence = false;\n        for strategy in &plan.strategies {\n            match strategy {\n                CorrectionStrategy::UpdatePath { .. } => {\n                    has_path_coherence = true;\n                    break;\n                }\n                CorrectionStrategy::UpdateCaller { old_ref, .. } => {\n                    let trimmed = old_ref.trim_start();\n                    if trimmed.starts_with(\"mod \")\n                        || trimmed.starts_with(\"pub mod \")\n                        || trimmed.starts_with(\"use \")\n                        || trimmed.starts_with(\"#[path\")\n                    {\n                        has_path_coherence = true;\n                        break;\n                    }\n                }\n                _ => {}\n            }\n        }\n        let is_rename_file = plan.action_id.starts_with(\"rename_file_\");\n\n        if !(has_path_coherence || is_rename_file) {\n            continue;\n        }\n\n        plans.push(plan.clone());\n        if let Some(policy) = report.verification_policies.get(idx) {\n            policies.push(policy.clone());\n        }\n        if let Some(rollback) = report.rollback_criteria.get(idx) {\n            criteria.push(rollback.clone());\n        }\n        if let Some(delta) = report.quality_deltas.get(idx) {\n            deltas.push(delta.clone());\n        }\n    }\n\n    let summary = compute_summary(&plans, &deltas);\n\n    CorrectionIntelligenceReport {\n        version: report.version.clone(),\n        timestamp: report.timestamp.clone(),\n        project_root: report.project_root.clone(),\n        actions_analyzed: plans.len(),\n        correction_plans: plans,\n        verification_policies: policies,\n        rollback_criteria: criteria,\n        quality_deltas: deltas,\n        summary,\n    }\n}\n\npub fn filter_visibility_report(\n    report: &CorrectionIntelligenceReport,\n) -> CorrectionIntelligenceReport {\n    let mut plans = Vec::new();\n    let mut policies = Vec::new();\n    let mut criteria = Vec::new();\n    let mut deltas = Vec::new();\n\n    for (idx, plan) in report.correction_plans.iter().enumerate() {\n        let mut has_visibility = false;\n        for strategy in &plan.strategies {\n            match strategy {\n                CorrectionStrategy::AdjustVisibility { .. } => {\n                    has_visibility = true;\n                    break;\n                }\n                CorrectionStrategy::VisibilityPlan { .. } => {\n                    has_visibility = true;\n                    break;\n                }\n                CorrectionStrategy::ManualReview { reason, .. }\n                    if reason.starts_with(\"review:\") =>\n                {\n                    has_visibility = true;\n                    break;\n                }\n                _ => {}\n            }\n        }\n        if !has_visibility {\n            continue;\n        }\n        plans.push(plan.clone());\n        if let Some(policy) = report.verification_policies.get(idx) {\n            policies.push(policy.clone());\n        }\n        if let Some(rollback) = report.rollback_criteria.get(idx) {\n            criteria.push(rollback.clone());\n        }\n        if let Some(delta) = report.quality_deltas.get(idx) {\n            deltas.push(delta.clone());\n        }\n    }\n\n    let summary = compute_summary(&plans, &deltas);\n\n    CorrectionIntelligenceReport {\n        version: report.version.clone(),\n        timestamp: report.timestamp.clone(),\n        project_root: report.project_root.clone(),\n        actions_analyzed: plans.len(),\n        correction_plans: plans,\n        verification_policies: policies,\n        rollback_criteria: criteria,\n        quality_deltas: deltas,\n        summary,\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct ClusterMove {\n    function: String,\n    from: PathBuf,\n}\n\n#[derive(Clone, Debug)]\nstruct ClusterBatch {\n    target: PathBuf,\n    moves: Vec<ClusterMove>,\n}\n\nfn parse_phase2_cluster_plan(plan_path: &Path) -> std::io::Result<Vec<ClusterBatch>> {\n    let contents = fs::read_to_string(plan_path)?;\n    let batch_re =\n        Regex::new(r\"^#### Batch \\d+: target `([^`]+)`\").map_err(|err| {\n            std::io::Error::new(std::io::ErrorKind::InvalidData, err.to_string())\n        })?;\n    let move_re = Regex::new(r\"^- Move `([^`]+)` from `([^`]+)`\").map_err(|err| {\n        std::io::Error::new(std::io::ErrorKind::InvalidData, err.to_string())\n    })?;\n    let mut batches = Vec::new();\n    let mut current: Option<ClusterBatch> = None;\n\n    for line in contents.lines() {\n        if let Some(captures) = batch_re.captures(line) {\n            if let Some(batch) = current.take() {\n                batches.push(batch);\n            }\n            current = Some(ClusterBatch {\n                target: PathBuf::from(&captures[1]),\n                moves: Vec::new(),\n            });\n            continue;\n        }\n\n        if let Some(captures) = move_re.captures(line) {\n            if let Some(batch) = current.as_mut() {\n                batch.moves.push(ClusterMove {\n                    function: captures[1].to_string(),\n                    from: PathBuf::from(&captures[2]),\n                });\n            }\n        }\n    }\n\n    if let Some(batch) = current {\n        batches.push(batch);\n    }\n\n    Ok(batches)\n}\n\npub fn generate_phase2_cluster_slice(\n    plan_path: &Path,\n    batch_index: usize,\n    root: &Path,\n) -> std::io::Result<CorrectionIntelligenceReport> {\n    let batches = parse_phase2_cluster_plan(plan_path)?;\n    let batch = batches.get(batch_index.saturating_sub(1)).ok_or_else(|| {\n        std::io::Error::new(\n            std::io::ErrorKind::InvalidData,\n            format!(\"Batch {} not found in {:?}\", batch_index, plan_path),\n        )\n    })?;\n    if batch.moves.is_empty() {\n        return Err(std::io::Error::new(\n            std::io::ErrorKind::InvalidData,\n            format!(\n                \"Batch {} in {:?} has no move entries\",\n                batch_index, plan_path\n            ),\n        ));\n    }\n\n    let mut plans = Vec::new();\n    let mut policies = Vec::new();\n    let mut criteria = Vec::new();\n    let mut deltas = Vec::new();\n\n    for entry in &batch.moves {\n        let action = RefactorAction::MoveFunction {\n            function: entry.function.clone(),\n            from: entry.from.clone(),\n            to: batch.target.clone(),\n            required_layer: Some(batch.target.display().to_string()),\n        };\n        let predictions = vec![ViolationPrediction {\n            violation_type: ViolationType::LayerViolation,\n            affected_files: vec![entry.from.clone(), batch.target.clone()],\n            severity: Severity::Medium,\n            confidence: 0.6,\n        }];\n        let plan = generate_correction_plan(&action, &predictions);\n        let policy = plan_verification_scope(&action, &plan);\n        let rollback = build_rollback_criteria(&action, &plan);\n        let delta = QualityDelta {\n            action_id: plan.action_id.clone(),\n            cohesion_delta: 0.0,\n            violation_delta: 0,\n            complexity_delta: 0.0,\n            overall_score_delta: 0.0,\n            acceptable: true,\n            reason: \"Not estimated for cluster slice\".to_string(),\n        };\n        plans.push(plan);\n        policies.push(policy);\n        criteria.push(rollback);\n        deltas.push(delta);\n    }\n\n    let summary = compute_summary(&plans, &deltas);\n\n    Ok(CorrectionIntelligenceReport {\n        version: \"1.0\".to_string(),\n        timestamp: chrono::Utc::now().to_rfc3339(),\n        project_root: root.to_path_buf(),\n        actions_analyzed: plans.len(),\n        correction_plans: plans,\n        verification_policies: policies,\n        rollback_criteria: criteria,\n        quality_deltas: deltas,\n        summary,\n    })\n}\n\npub(crate) fn augment_path_coherence_strategies(\n    plan: &mut CorrectionPlan,\n    action: &RefactorAction,\n    root: &Path,\n) {\n    let RefactorAction::RenameFile { from, to } = action else {\n        return;\n    };\n    let Some(old_mod) = module_name_from_path(from) else {\n        return;\n    };\n    let Some(new_mod) = module_name_from_path(to) else {\n        return;\n    };\n    let old_file_name = from.file_name().and_then(|s| s.to_str()).unwrap_or(\"\");\n    let new_file_name = to.file_name().and_then(|s| s.to_str()).unwrap_or(\"\");\n    let replace_mod = old_mod != new_mod;\n\n    let mod_re = if replace_mod {\n        Regex::new(&format!(\n            r\"^\\s*(pub\\s+)?mod\\s+{}\\s*;\",\n            regex::escape(&old_mod)\n        ))\n        .ok()\n    } else {\n        None\n    };\n    let use_re = if replace_mod {\n        Regex::new(&format!(\n            r\"^\\s*use\\s+.*\\b{}\\b\",\n            regex::escape(&old_mod)\n        ))\n        .ok()\n    } else {\n        None\n    };\n    let path_re = if !old_file_name.is_empty() && !new_file_name.is_empty() {\n        Regex::new(r#\"^\\s*#\\s*\\[\\s*path\\s*=\\s*\"([^\"]+)\"\\s*\\]\"#).ok()\n    } else {\n        None\n    };\n\n    let mut updates = Vec::new();\n    let mut seen = HashSet::new();\n    let rust_files = crate::cluster_010::gather_rust_files(root);\n\n    for file in rust_files {\n        let Ok(contents) = fs::read_to_string(&file) else {\n            continue;\n        };\n        for line in contents.lines() {\n            if let Some(re) = &mod_re {\n                if re.is_match(line) {\n                    let new_line = line.replace(&old_mod, &new_mod);\n                    if new_line != line {\n                        let key = (file.clone(), line.to_string(), new_line.clone());\n                        if seen.insert(key.clone()) {\n                            updates.push(key);\n                        }\n                    }\n                    continue;\n                }\n            }\n            if let Some(re) = &use_re {\n                if re.is_match(line) {\n                    let new_line = line.replace(&old_mod, &new_mod);\n                    if new_line != line {\n                        let key = (file.clone(), line.to_string(), new_line.clone());\n                        if seen.insert(key.clone()) {\n                            updates.push(key);\n                        }\n                    }\n                    continue;\n                }\n            }\n            if let Some(re) = &path_re {\n                if re.is_match(line) && line.contains(old_file_name) {\n                    let new_line = line.replace(old_file_name, new_file_name);\n                    if new_line != line {\n                        let key = (file.clone(), line.to_string(), new_line.clone());\n                        if seen.insert(key.clone()) {\n                            updates.push(key);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    updates.sort_by(|a, b| {\n        a.0.cmp(&b.0)\n            .then_with(|| a.1.cmp(&b.1))\n            .then_with(|| a.2.cmp(&b.2))\n    });\n\n    for (file, old_ref, new_ref) in updates {\n        plan.strategies.push(CorrectionStrategy::UpdateCaller {\n            caller_file: file,\n            old_ref,\n            new_ref,\n        });\n    }\n}\n\nfn module_name_from_path(path: &Path) -> Option<String> {\n    let stem = path.file_stem().and_then(|s| s.to_str())?;\n    let name = if stem == \"mod\" {\n        path.parent()\n            .and_then(|p| p.file_name())\n            .and_then(|n| n.to_str())?\n            .to_string()\n    } else {\n        stem.to_string()\n    };\n    Some(crate::cluster_010::normalize_module_name(&name))\n}\n\n\n\n\n\npub(crate) fn compute_summary(plans: &[CorrectionPlan], deltas: &[QualityDelta]) -> CorrectionSummary {\n    let mut trivial = 0;\n    let mut moderate = 0;\n    let mut complex = 0;\n    let mut total_violations = 0;\n    let mut total_confidence = 0.0;\n    let mut total_time = 0;\n\n    for plan in plans {\n        match plan.tier {\n            ErrorTier::Trivial => trivial += 1,\n            ErrorTier::Moderate => moderate += 1,\n            ErrorTier::Complex => complex += 1,\n        }\n        total_violations += plan.predicted_violations.len();\n        total_confidence += plan.confidence;\n        total_time += plan.estimated_fix_time_seconds;\n    }\n\n    let avg_conf = if plans.is_empty() {\n        0.0\n    } else {\n        total_confidence / plans.len() as f64\n    };\n\n    let _ = deltas;\n\n    CorrectionSummary {\n        trivial_count: trivial,\n        moderate_count: moderate,\n        complex_count: complex,\n        total_predicted_violations: total_violations,\n        average_confidence: avg_conf,\n        estimated_total_fix_time_seconds: total_time,\n    }\n}\n\npub(crate) fn fill_prediction_confidence(predictions: &mut [ViolationPrediction]) {\n    for prediction in predictions {\n        if prediction.confidence <= 0.0 {\n            prediction.confidence = default_confidence(&prediction.violation_type);\n        }\n    }\n}\n\nfn default_confidence(violation_type: &crate::correction_plan_types::ViolationType) -> f64 {\n    match violation_type {\n        crate::correction_plan_types::ViolationType::UnresolvedImport => 0.95,\n        crate::correction_plan_types::ViolationType::NameCollision => 1.0,\n        crate::correction_plan_types::ViolationType::LayerViolation => 0.9,\n        crate::correction_plan_types::ViolationType::VisibilityMismatch => 0.8,\n        crate::correction_plan_types::ViolationType::BrokenReference => 0.85,\n        crate::correction_plan_types::ViolationType::TypeMismatch => 0.6,\n        crate::correction_plan_types::ViolationType::OwnershipIssue => 0.5,\n    }\n}\n\npub fn calculate_quality_delta(\n    action: &RefactorAction,\n    current: &Metrics,\n    simulated: &Metrics,\n) -> QualityDelta {\n    let cohesion_delta = simulated.cohesion - current.cohesion;\n    let violation_delta = simulated.violations as i32 - current.violations as i32;\n    let complexity_delta = simulated.complexity - current.complexity;\n    let overall = 0.5 * cohesion_delta - 0.3 * violation_delta as f64 - 0.2 * complexity_delta;\n    let acceptable = overall > -0.05 && violation_delta <= 0;\n    let reason = if acceptable {\n        \"Quality improved or maintained\".to_string()\n    } else if overall < -0.1 {\n        \"Quality degradation exceeds threshold\".to_string()\n    } else if violation_delta > 0 {\n        format!(\"Introduced {} new violations\", violation_delta)\n    } else {\n        \"Quality barely acceptable\".to_string()\n    };\n    QualityDelta {\n        action_id: action.action_id(),\n        cohesion_delta,\n        violation_delta,\n        complexity_delta,\n        overall_score_delta: overall,\n        acceptable,\n        reason,\n    }\n}\n",
          "updated_content": "#![allow(dead_code)]\n//! Correction intelligence report generator.\n\nuse crate::correction_plan_types::{\n    CorrectionPlan, CorrectionStrategy, ErrorTier, RefactorAction, Severity, ViolationPrediction,\n    ViolationType,\n};\nuse crate::quality_delta_calculator::Metrics;\nuse crate::quality_delta_types::{QualityDelta, RollbackCriteria};\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse std::{collections::HashSet, fs};\n\nuse crate::invariant_types::InvariantAnalysisResult;\nuse crate::types::{AnalysisResult, CallGraphNode, CodeElement};\n\npub use crate::correction_plan_serializer::write_intelligence_outputs_at;\npub use crate::violation_predictor::generate_intelligence_report;\nuse crate::{\n    correction_plan_generator::generate_correction_plan,\n    rollback_criteria_builder::build_rollback_criteria,\n    verification_scope_planner::plan_verification_scope,\n};\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct CorrectionIntelligenceReport {\n    pub version: String,\n    pub timestamp: String,\n    pub project_root: PathBuf,\n    pub actions_analyzed: usize,\n    pub correction_plans: Vec<CorrectionPlan>,\n    pub verification_policies: Vec<crate::verification_policy_types::VerificationPolicy>,\n    pub rollback_criteria: Vec<RollbackCriteria>,\n    pub quality_deltas: Vec<QualityDelta>,\n    pub summary: CorrectionSummary,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct CorrectionSummary {\n    pub trivial_count: usize,\n    pub moderate_count: usize,\n    pub complex_count: usize,\n    pub total_predicted_violations: usize,\n    pub average_confidence: f64,\n    pub estimated_total_fix_time_seconds: u32,\n}\n\n#[derive(Clone, Debug)]\npub struct IntelligenceState<'a> {\n    pub root: PathBuf,\n    pub invariants: &'a InvariantAnalysisResult,\n    pub call_graph: &'a HashMap<String, CallGraphNode>,\n    pub elements: &'a [CodeElement],\n    pub metrics: Metrics,\n}\n\npub fn build_state<'a>(\n    root: &'a Path,\n    analysis: &'a AnalysisResult,\n    metrics: Metrics,\n) -> IntelligenceState<'a> {\n    IntelligenceState {\n        root: root.to_path_buf(),\n        invariants: &analysis.invariants,\n        call_graph: &analysis.call_graph,\n        elements: &analysis.elements,\n        metrics,\n    }\n}\n\n\n\npub fn write_intelligence_outputs(\n    report: &CorrectionIntelligenceReport,\n    output_dir: &Path,\n) -> std::io::Result<()> {\n    write_intelligence_outputs_at(report, output_dir, None, None)\n}\n\npub fn filter_path_coherence_report(\n    report: &CorrectionIntelligenceReport,\n) -> CorrectionIntelligenceReport {\n    let mut plans = Vec::new();\n    let mut policies = Vec::new();\n    let mut criteria = Vec::new();\n    let mut deltas = Vec::new();\n\n    for (idx, plan) in report.correction_plans.iter().enumerate() {\n        let mut has_path_coherence = false;\n        for strategy in &plan.strategies {\n            match strategy {\n                CorrectionStrategy::UpdatePath { .. } => {\n                    has_path_coherence = true;\n                    break;\n                }\n                CorrectionStrategy::UpdateCaller { old_ref, .. } => {\n                    let trimmed = old_ref.trim_start();\n                    if trimmed.starts_with(\"mod \")\n                        || trimmed.starts_with(\"pub mod \")\n                        || trimmed.starts_with(\"use \")\n                        || trimmed.starts_with(\"#[path\")\n                    {\n                        has_path_coherence = true;\n                        break;\n                    }\n                }\n                _ => {}\n            }\n        }\n        let is_rename_file = plan.action_id.starts_with(\"rename_file_\");\n\n        if !(has_path_coherence || is_rename_file) {\n            continue;\n        }\n\n        plans.push(plan.clone());\n        if let Some(policy) = report.verification_policies.get(idx) {\n            policies.push(policy.clone());\n        }\n        if let Some(rollback) = report.rollback_criteria.get(idx) {\n            criteria.push(rollback.clone());\n        }\n        if let Some(delta) = report.quality_deltas.get(idx) {\n            deltas.push(delta.clone());\n        }\n    }\n\n    let summary = compute_summary(&plans, &deltas);\n\n    CorrectionIntelligenceReport {\n        version: report.version.clone(),\n        timestamp: report.timestamp.clone(),\n        project_root: report.project_root.clone(),\n        actions_analyzed: plans.len(),\n        correction_plans: plans,\n        verification_policies: policies,\n        rollback_criteria: criteria,\n        quality_deltas: deltas,\n        summary,\n    }\n}\n\npub fn filter_visibility_report(\n    report: &CorrectionIntelligenceReport,\n) -> CorrectionIntelligenceReport {\n    let mut plans = Vec::new();\n    let mut policies = Vec::new();\n    let mut criteria = Vec::new();\n    let mut deltas = Vec::new();\n\n    for (idx, plan) in report.correction_plans.iter().enumerate() {\n        let mut has_visibility = false;\n        for strategy in &plan.strategies {\n            match strategy {\n                CorrectionStrategy::AdjustVisibility { .. } => {\n                    has_visibility = true;\n                    break;\n                }\n                CorrectionStrategy::VisibilityPlan { .. } => {\n                    has_visibility = true;\n                    break;\n                }\n                CorrectionStrategy::ManualReview { reason, .. }\n                    if reason.starts_with(\"review:\") =>\n                {\n                    has_visibility = true;\n                    break;\n                }\n                _ => {}\n            }\n        }\n        if !has_visibility {\n            continue;\n        }\n        plans.push(plan.clone());\n        if let Some(policy) = report.verification_policies.get(idx) {\n            policies.push(policy.clone());\n        }\n        if let Some(rollback) = report.rollback_criteria.get(idx) {\n            criteria.push(rollback.clone());\n        }\n        if let Some(delta) = report.quality_deltas.get(idx) {\n            deltas.push(delta.clone());\n        }\n    }\n\n    let summary = compute_summary(&plans, &deltas);\n\n    CorrectionIntelligenceReport {\n        version: report.version.clone(),\n        timestamp: report.timestamp.clone(),\n        project_root: report.project_root.clone(),\n        actions_analyzed: plans.len(),\n        correction_plans: plans,\n        verification_policies: policies,\n        rollback_criteria: criteria,\n        quality_deltas: deltas,\n        summary,\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct ClusterMove {\n    function: String,\n    from: PathBuf,\n}\n\n#[derive(Clone, Debug)]\nstruct ClusterBatch {\n    target: PathBuf,\n    moves: Vec<ClusterMove>,\n}\n\nfn parse_phase2_cluster_plan(plan_path: &Path) -> std::io::Result<Vec<ClusterBatch>> {\n    let contents = fs::read_to_string(plan_path)?;\n    let batch_re =\n        Regex::new(r\"^#### Batch \\d+: target `([^`]+)`\").map_err(|err| {\n            std::io::Error::new(std::io::ErrorKind::InvalidData, err.to_string())\n        })?;\n    let move_re = Regex::new(r\"^- Move `([^`]+)` from `([^`]+)`\").map_err(|err| {\n        std::io::Error::new(std::io::ErrorKind::InvalidData, err.to_string())\n    })?;\n    let mut batches = Vec::new();\n    let mut current: Option<ClusterBatch> = None;\n\n    for line in contents.lines() {\n        if let Some(captures) = batch_re.captures(line) {\n            if let Some(batch) = current.take() {\n                batches.push(batch);\n            }\n            current = Some(ClusterBatch {\n                target: PathBuf::from(&captures[1]),\n                moves: Vec::new(),\n            });\n            continue;\n        }\n\n        if let Some(captures) = move_re.captures(line) {\n            if let Some(batch) = current.as_mut() {\n                batch.moves.push(ClusterMove {\n                    function: captures[1].to_string(),\n                    from: PathBuf::from(&captures[2]),\n                });\n            }\n        }\n    }\n\n    if let Some(batch) = current {\n        batches.push(batch);\n    }\n\n    Ok(batches)\n}\n\npub fn generate_phase2_cluster_slice(\n    plan_path: &Path,\n    batch_index: usize,\n    root: &Path,\n) -> std::io::Result<CorrectionIntelligenceReport> {\n    let batches = parse_phase2_cluster_plan(plan_path)?;\n    let batch = batches.get(batch_index.saturating_sub(1)).ok_or_else(|| {\n        std::io::Error::new(\n            std::io::ErrorKind::InvalidData,\n            format!(\"Batch {} not found in {:?}\", batch_index, plan_path),\n        )\n    })?;\n    if batch.moves.is_empty() {\n        return Err(std::io::Error::new(\n            std::io::ErrorKind::InvalidData,\n            format!(\n                \"Batch {} in {:?} has no move entries\",\n                batch_index, plan_path\n            ),\n        ));\n    }\n\n    let mut plans = Vec::new();\n    let mut policies = Vec::new();\n    let mut criteria = Vec::new();\n    let mut deltas = Vec::new();\n\n    for entry in &batch.moves {\n        let action = RefactorAction::MoveFunction {\n            function: entry.function.clone(),\n            from: entry.from.clone(),\n            to: batch.target.clone(),\n            required_layer: Some(batch.target.display().to_string()),\n        };\n        let predictions = vec![ViolationPrediction {\n            violation_type: ViolationType::LayerViolation,\n            affected_files: vec![entry.from.clone(), batch.target.clone()],\n            severity: Severity::Medium,\n            confidence: 0.6,\n        }];\n        let plan = generate_correction_plan(&action, &predictions);\n        let policy = plan_verification_scope(&action, &plan);\n        let rollback = build_rollback_criteria(&action, &plan);\n        let delta = QualityDelta {\n            action_id: plan.action_id.clone(),\n            cohesion_delta: 0.0,\n            violation_delta: 0,\n            complexity_delta: 0.0,\n            overall_score_delta: 0.0,\n            acceptable: true,\n            reason: \"Not estimated for cluster slice\".to_string(),\n        };\n        plans.push(plan);\n        policies.push(policy);\n        criteria.push(rollback);\n        deltas.push(delta);\n    }\n\n    let summary = compute_summary(&plans, &deltas);\n\n    Ok(CorrectionIntelligenceReport {\n        version: \"1.0\".to_string(),\n        timestamp: chrono::Utc::now().to_rfc3339(),\n        project_root: root.to_path_buf(),\n        actions_analyzed: plans.len(),\n        correction_plans: plans,\n        verification_policies: policies,\n        rollback_criteria: criteria,\n        quality_deltas: deltas,\n        summary,\n    })\n}\n\npub(crate) fn augment_path_coherence_strategies(\n    plan: &mut CorrectionPlan,\n    action: &RefactorAction,\n    root: &Path,\n) {\n    let RefactorAction::RenameFile { from, to } = action else {\n        return;\n    };\n    let Some(old_mod) = module_name_from_path(from) else {\n        return;\n    };\n    let Some(new_mod) = module_name_from_path(to) else {\n        return;\n    };\n    let old_file_name = from.file_name().and_then(|s| s.to_str()).unwrap_or(\"\");\n    let new_file_name = to.file_name().and_then(|s| s.to_str()).unwrap_or(\"\");\n    let replace_mod = old_mod != new_mod;\n\n    let mod_re = if replace_mod {\n        Regex::new(&format!(\n            r\"^\\s*(pub\\s+)?mod\\s+{}\\s*;\",\n            regex::escape(&old_mod)\n        ))\n        .ok()\n    } else {\n        None\n    };\n    let use_re = if replace_mod {\n        Regex::new(&format!(\n            r\"^\\s*use\\s+.*\\b{}\\b\",\n            regex::escape(&old_mod)\n        ))\n        .ok()\n    } else {\n        None\n    };\n    let path_re = if !old_file_name.is_empty() && !new_file_name.is_empty() {\n        Regex::new(r#\"^\\s*#\\s*\\[\\s*path\\s*=\\s*\"([^\"]+)\"\\s*\\]\"#).ok()\n    } else {\n        None\n    };\n\n    let mut updates = Vec::new();\n    let mut seen = HashSet::new();\n    let rust_files = crate::cluster_010::gather_rust_files(root);\n\n    for file in rust_files {\n        let Ok(contents) = fs::read_to_string(&file) else {\n            continue;\n        };\n        for line in contents.lines() {\n            if let Some(re) = &mod_re {\n                if re.is_match(line) {\n                    let new_line = line.replace(&old_mod, &new_mod);\n                    if new_line != line {\n                        let key = (file.clone(), line.to_string(), new_line.clone());\n                        if seen.insert(key.clone()) {\n                            updates.push(key);\n                        }\n                    }\n                    continue;\n                }\n            }\n            if let Some(re) = &use_re {\n                if re.is_match(line) {\n                    let new_line = line.replace(&old_mod, &new_mod);\n                    if new_line != line {\n                        let key = (file.clone(), line.to_string(), new_line.clone());\n                        if seen.insert(key.clone()) {\n                            updates.push(key);\n                        }\n                    }\n                    continue;\n                }\n            }\n            if let Some(re) = &path_re {\n                if re.is_match(line) && line.contains(old_file_name) {\n                    let new_line = line.replace(old_file_name, new_file_name);\n                    if new_line != line {\n                        let key = (file.clone(), line.to_string(), new_line.clone());\n                        if seen.insert(key.clone()) {\n                            updates.push(key);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    updates.sort_by(|a, b| {\n        a.0.cmp(&b.0)\n            .then_with(|| a.1.cmp(&b.1))\n            .then_with(|| a.2.cmp(&b.2))\n    });\n\n    for (file, old_ref, new_ref) in updates {\n        plan.strategies.push(CorrectionStrategy::UpdateCaller {\n            caller_file: file,\n            old_ref,\n            new_ref,\n        });\n    }\n}\n\nfn module_name_from_path(path: &Path) -> Option<String> {\n    let stem = path.file_stem().and_then(|s| s.to_str())?;\n    let name = if stem == \"mod\" {\n        path.parent()\n            .and_then(|p| p.file_name())\n            .and_then(|n| n.to_str())?\n            .to_string()\n    } else {\n        stem.to_string()\n    };\n    Some(crate::cluster_010::normalize_module_name(&name))\n}\n\n\n\n\n\npub(crate) fn compute_summary(plans: &[CorrectionPlan], deltas: &[QualityDelta]) -> CorrectionSummary {\n    let mut trivial = 0;\n    let mut moderate = 0;\n    let mut complex = 0;\n    let mut total_violations = 0;\n    let mut total_confidence = 0.0;\n    let mut total_time = 0;\n\n    for plan in plans {\n        match plan.tier {\n            ErrorTier::Trivial => trivial += 1,\n            ErrorTier::Moderate => moderate += 1,\n            ErrorTier::Complex => complex += 1,\n        }\n        total_violations += plan.predicted_violations.len();\n        total_confidence += plan.confidence;\n        total_time += plan.estimated_fix_time_seconds;\n    }\n\n    let avg_conf = if plans.is_empty() {\n        0.0\n    } else {\n        total_confidence / plans.len() as f64\n    };\n\n    let _ = deltas;\n\n    CorrectionSummary {\n        trivial_count: trivial,\n        moderate_count: moderate,\n        complex_count: complex,\n        total_predicted_violations: total_violations,\n        average_confidence: avg_conf,\n        estimated_total_fix_time_seconds: total_time,\n    }\n}\n\npub(crate) fn fill_prediction_confidence(predictions: &mut [ViolationPrediction]) {\n    for prediction in predictions {\n        if prediction.confidence <= 0.0 {\n            prediction.confidence = default_confidence(&prediction.violation_type);\n        }\n    }\n}\n\nfn default_confidence(violation_type: &crate::correction_plan_types::ViolationType) -> f64 {\n    match violation_type {\n        crate::correction_plan_types::ViolationType::UnresolvedImport => 0.95,\n        crate::correction_plan_types::ViolationType::NameCollision => 1.0,\n        crate::correction_plan_types::ViolationType::LayerViolation => 0.9,\n        crate::correction_plan_types::ViolationType::VisibilityMismatch => 0.8,\n        crate::correction_plan_types::ViolationType::BrokenReference => 0.85,\n        crate::correction_plan_types::ViolationType::TypeMismatch => 0.6,\n        crate::correction_plan_types::ViolationType::OwnershipIssue => 0.5,\n    }\n}\n\npub fn calculate_quality_delta(\n    action: &RefactorAction,\n    current: &Metrics,\n    simulated: &Metrics,\n) -> QualityDelta {\n    let cohesion_delta = simulated.cohesion - current.cohesion;\n    let violation_delta = simulated.violations as i32 - current.violations as i32;\n    let complexity_delta = simulated.complexity - current.complexity;\n    let overall = 0.5 * cohesion_delta - 0.3 * violation_delta as f64 - 0.2 * complexity_delta;\n    let acceptable = overall > -0.05 && violation_delta <= 0;\n    let reason = if acceptable {\n        \"Quality improved or maintained\".to_string()\n    } else if overall < -0.1 {\n        \"Quality degradation exceeds threshold\".to_string()\n    } else if violation_delta > 0 {\n        format!(\"Introduced {} new violations\", violation_delta)\n    } else {\n        \"Quality barely acceptable\".to_string()\n    };\n    QualityDelta {\n        action_id: action.action_id(),\n        cohesion_delta,\n        violation_delta,\n        complexity_delta,\n        overall_score_delta: overall,\n        acceptable,\n        reason,\n    }\n}\n\npub(crate) fn action_function(action: &RefactorAction) -> Option<String> {\n    match action {\n        RefactorAction::MoveFunction { function, .. } => Some(function.clone()),\n        _ => None,\n    }\n}\n"
        },
        {
          "type": "FileEdit",
          "path": "tools/mmsb-analyzer/src/600_quality_delta_calculator.rs",
          "original_content": "#![allow(dead_code)]\n//! Quality delta calculator.\n\nuse crate::correction_plan_types::RefactorAction;\nuse crate::quality_delta_types::QualityDelta;\nuse crate::action_impact_estimator::{AnalysisState, simulate_action};\n\n#[derive(Clone, Debug, Default)]\npub struct Metrics {\n    pub cohesion: f64,\n    pub violations: usize,\n    pub complexity: f64,\n}\n\n\n\npub fn estimate_impact(action: &RefactorAction, current_state: &AnalysisState) -> QualityDelta {\n    let simulated = simulate_action(action, current_state);\n    calculate_quality_delta(action, &current_state.metrics, &simulated.metrics)\n}\n\n#[path = \"640_correction_intelligence_report.rs\"]\nmod moved_calculate_quality_delta;\npub use moved_calculate_quality_delta::calculate_quality_delta;\n",
          "updated_content": "#![allow(dead_code)]\n//! Quality delta calculator.\n\nuse crate::correction_plan_types::RefactorAction;\nuse crate::quality_delta_types::QualityDelta;\nuse crate::action_impact_estimator::{AnalysisState, simulate_action};\n\n#[derive(Clone, Debug, Default)]\npub struct Metrics {\n    pub cohesion: f64,\n    pub violations: usize,\n    pub complexity: f64,\n}\n\n\n\npub fn estimate_impact(action: &RefactorAction, current_state: &AnalysisState) -> QualityDelta {\n    let simulated = simulate_action(action, current_state);\n    calculate_quality_delta(action, &current_state.metrics, &simulated.metrics)\n}\n\npub use crate::correction_intelligence_report::calculate_quality_delta;\n"
        }
      ],
      "applied": false,
      "errors": []
    }
  ]
}