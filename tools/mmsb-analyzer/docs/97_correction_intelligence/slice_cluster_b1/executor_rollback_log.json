{
  "version": "1.0",
  "timestamp": "2026-01-01T05:00:53.931247427+00:00",
  "actions": [
    {
      "action_id": "move_find_element_file_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_symbol_exists_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_move_violates_invariant_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_average_confidence_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_estimate_fix_time_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_action_symbol_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_action_function_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_action_module_path_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_action_refs_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_action_target_layer_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_action_visibility_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_affected_files_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_action_module_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_estimate_verification_time_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_extract_critical_tests_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_calculate_quality_delta_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_simulate_action_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_find_callers_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_find_reference_files_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_generate_correction_plan_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_plan_verification_scope_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_build_rollback_criteria_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_estimate_impact_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_predict_violations_to_src/640_correction_intelligence_report.rs",
      "mutations": [],
      "applied": false,
      "errors": []
    },
    {
      "action_id": "move_generate_intelligence_report_to_src/640_correction_intelligence_report.rs",
      "mutations": [
        {
          "type": "FileEdit",
          "path": "tools/mmsb-analyzer/src/530_violation_predictor.rs",
          "original_content": "#![allow(dead_code)]\n//! Predict violations for refactor actions.\n\nuse crate::correction_plan_types::{\n    RefactorAction,\n};\nuse crate::correction_intelligence_report::{\n    augment_path_coherence_strategies,\n    compute_summary,\n    fill_prediction_confidence,\n    CorrectionIntelligenceReport,\n    IntelligenceState,\n};\nuse crate::correction_plan_generator::generate_correction_plan;\nuse crate::rollback_criteria_builder::build_rollback_criteria;\nuse crate::verification_scope_planner::plan_verification_scope;\nuse crate::action_impact_estimator::{estimate_impact, AnalysisState as ImpactState};\n#[allow(unused_imports)] pub use crate::correction_intelligence_report::predict_violations;\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn generate_intelligence_report(\n    actions: &[RefactorAction],\n    state: &IntelligenceState<'_>,\n) -> CorrectionIntelligenceReport {\n    let mut plans = Vec::new();\n    let mut policies = Vec::new();\n    let mut criteria = Vec::new();\n    let mut deltas = Vec::new();\n\n    for action in actions {\n        let mut predictions =\n            predict_violations(action, state.invariants, state.call_graph, state.elements);\n        fill_prediction_confidence(&mut predictions);\n        let mut plan = generate_correction_plan(action, &predictions);\n        augment_path_coherence_strategies(&mut plan, action, &state.root);\n        let policy = plan_verification_scope(action, &plan);\n        let rollback = build_rollback_criteria(action, &plan);\n        let delta = estimate_impact(action, &ImpactState {\n            metrics: state.metrics.clone(),\n        });\n\n        plans.push(plan);\n        policies.push(policy);\n        criteria.push(rollback);\n        deltas.push(delta);\n    }\n\n    let summary = compute_summary(&plans, &deltas);\n\n    CorrectionIntelligenceReport {\n        version: \"1.0\".to_string(),\n        timestamp: chrono::Utc::now().to_rfc3339(),\n        project_root: state.root.clone(),\n        actions_analyzed: actions.len(),\n        correction_plans: plans,\n        verification_policies: policies,\n        rollback_criteria: criteria,\n        quality_deltas: deltas,\n        summary,\n    }\n}\n",
          "updated_content": "#![allow(dead_code)]\n//! Predict violations for refactor actions.\n\n#[allow(unused_imports)] pub use crate::correction_intelligence_report::generate_intelligence_report;\n#[allow(unused_imports)] pub use crate::correction_intelligence_report::predict_violations;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
          "type": "FileEdit",
          "path": "tools/mmsb-analyzer/src/640_correction_intelligence_report.rs",
          "original_content": "#![allow(dead_code)]\n//! Correction intelligence report generator.\n\nuse crate::correction_plan_types::{\n    CorrectionPlan,\n    CorrectionStrategy,\n    ErrorTier,\n    RefactorAction,\n    Severity,\n    ViolationPrediction,\n    ViolationType,\n};\nuse crate::quality_delta_calculator::Metrics;\nuse crate::quality_delta_types::{QualityDelta, RollbackCriteria};\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse std::{collections::HashSet, fs};\n\nuse crate::invariant_types::InvariantAnalysisResult;\nuse crate::types::{AnalysisResult, CallGraphNode, CodeElement};\n\n#[allow(unused_imports)] pub use crate::correction_plan_serializer::write_intelligence_outputs_at;\n#[allow(unused_imports)] pub use crate::violation_predictor::generate_intelligence_report;\nuse crate::action_impact_estimator::AnalysisState;\nuse crate::correction_plan_types::VisibilityPlanOption;\nuse crate::tier_classifier::classify_tier;\nuse crate::verification_policy_types::VerificationCheck;\nuse crate::verification_policy_types::VerificationPolicy;\nuse crate::verification_policy_types::VerificationScope;\nuse crate::quality_delta_types::RollbackCondition;\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct CorrectionIntelligenceReport {\n    pub version: String,\n    pub timestamp: String,\n    pub project_root: PathBuf,\n    pub actions_analyzed: usize,\n    pub correction_plans: Vec<CorrectionPlan>,\n    pub verification_policies: Vec<crate::verification_policy_types::VerificationPolicy>,\n    pub rollback_criteria: Vec<RollbackCriteria>,\n    pub quality_deltas: Vec<QualityDelta>,\n    pub summary: CorrectionSummary,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct CorrectionSummary {\n    pub trivial_count: usize,\n    pub moderate_count: usize,\n    pub complex_count: usize,\n    pub total_predicted_violations: usize,\n    pub average_confidence: f64,\n    pub estimated_total_fix_time_seconds: u32,\n}\n\n#[derive(Clone, Debug)]\npub struct IntelligenceState<'a> {\n    pub root: PathBuf,\n    pub invariants: &'a InvariantAnalysisResult,\n    pub call_graph: &'a HashMap<String, CallGraphNode>,\n    pub elements: &'a [CodeElement],\n    pub metrics: Metrics,\n}\n\npub fn build_state<'a>(\n    root: &'a Path,\n    analysis: &'a AnalysisResult,\n    metrics: Metrics,\n) -> IntelligenceState<'a> {\n    IntelligenceState {\n        root: root.to_path_buf(),\n        invariants: &analysis.invariants,\n        call_graph: &analysis.call_graph,\n        elements: &analysis.elements,\n        metrics,\n    }\n}\n\n\n\npub fn write_intelligence_outputs(\n    report: &CorrectionIntelligenceReport,\n    output_dir: &Path,\n) -> std::io::Result<()> {\n    write_intelligence_outputs_at(report, output_dir, None, None)\n}\n\npub fn filter_path_coherence_report(\n    report: &CorrectionIntelligenceReport,\n) -> CorrectionIntelligenceReport {\n    let mut plans = Vec::new();\n    let mut policies = Vec::new();\n    let mut criteria = Vec::new();\n    let mut deltas = Vec::new();\n\n    for (idx, plan) in report.correction_plans.iter().enumerate() {\n        let mut has_path_coherence = false;\n        for strategy in &plan.strategies {\n            match strategy {\n                CorrectionStrategy::UpdatePath { .. } => {\n                    has_path_coherence = true;\n                    break;\n                }\n                CorrectionStrategy::UpdateCaller { old_ref, .. } => {\n                    let trimmed = old_ref.trim_start();\n                    if trimmed.starts_with(\"mod \")\n                        || trimmed.starts_with(\"pub mod \")\n                        || trimmed.starts_with(\"use \")\n                        || trimmed.starts_with(\"#[path\")\n                    {\n                        has_path_coherence = true;\n                        break;\n                    }\n                }\n                _ => {}\n            }\n        }\n        let is_rename_file = plan.action_id.starts_with(\"rename_file_\");\n\n        if !(has_path_coherence || is_rename_file) {\n            continue;\n        }\n\n        plans.push(plan.clone());\n        if let Some(policy) = report.verification_policies.get(idx) {\n            policies.push(policy.clone());\n        }\n        if let Some(rollback) = report.rollback_criteria.get(idx) {\n            criteria.push(rollback.clone());\n        }\n        if let Some(delta) = report.quality_deltas.get(idx) {\n            deltas.push(delta.clone());\n        }\n    }\n\n    let summary = compute_summary(&plans, &deltas);\n\n    CorrectionIntelligenceReport {\n        version: report.version.clone(),\n        timestamp: report.timestamp.clone(),\n        project_root: report.project_root.clone(),\n        actions_analyzed: plans.len(),\n        correction_plans: plans,\n        verification_policies: policies,\n        rollback_criteria: criteria,\n        quality_deltas: deltas,\n        summary,\n    }\n}\n\npub fn filter_visibility_report(\n    report: &CorrectionIntelligenceReport,\n) -> CorrectionIntelligenceReport {\n    let mut plans = Vec::new();\n    let mut policies = Vec::new();\n    let mut criteria = Vec::new();\n    let mut deltas = Vec::new();\n\n    for (idx, plan) in report.correction_plans.iter().enumerate() {\n        let mut has_visibility = false;\n        for strategy in &plan.strategies {\n            match strategy {\n                CorrectionStrategy::AdjustVisibility { .. } => {\n                    has_visibility = true;\n                    break;\n                }\n                CorrectionStrategy::VisibilityPlan { .. } => {\n                    has_visibility = true;\n                    break;\n                }\n                CorrectionStrategy::ManualReview { reason, .. }\n                    if reason.starts_with(\"review:\") =>\n                {\n                    has_visibility = true;\n                    break;\n                }\n                _ => {}\n            }\n        }\n        if !has_visibility {\n            continue;\n        }\n        plans.push(plan.clone());\n        if let Some(policy) = report.verification_policies.get(idx) {\n            policies.push(policy.clone());\n        }\n        if let Some(rollback) = report.rollback_criteria.get(idx) {\n            criteria.push(rollback.clone());\n        }\n        if let Some(delta) = report.quality_deltas.get(idx) {\n            deltas.push(delta.clone());\n        }\n    }\n\n    let summary = compute_summary(&plans, &deltas);\n\n    CorrectionIntelligenceReport {\n        version: report.version.clone(),\n        timestamp: report.timestamp.clone(),\n        project_root: report.project_root.clone(),\n        actions_analyzed: plans.len(),\n        correction_plans: plans,\n        verification_policies: policies,\n        rollback_criteria: criteria,\n        quality_deltas: deltas,\n        summary,\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct ClusterMove {\n    function: String,\n    from: PathBuf,\n}\n\n#[derive(Clone, Debug)]\nstruct ClusterBatch {\n    target: PathBuf,\n    moves: Vec<ClusterMove>,\n}\n\nfn parse_phase2_cluster_plan(plan_path: &Path) -> std::io::Result<Vec<ClusterBatch>> {\n    let contents = fs::read_to_string(plan_path)?;\n    let batch_re =\n        Regex::new(r\"^#### Batch \\d+: target `([^`]+)`\").map_err(|err| {\n            std::io::Error::new(std::io::ErrorKind::InvalidData, err.to_string())\n        })?;\n    let move_re = Regex::new(r\"^- Move `([^`]+)` from `([^`]+)`\").map_err(|err| {\n        std::io::Error::new(std::io::ErrorKind::InvalidData, err.to_string())\n    })?;\n    let mut batches = Vec::new();\n    let mut current: Option<ClusterBatch> = None;\n\n    for line in contents.lines() {\n        if let Some(captures) = batch_re.captures(line) {\n            if let Some(batch) = current.take() {\n                batches.push(batch);\n            }\n            current = Some(ClusterBatch {\n                target: PathBuf::from(&captures[1]),\n                moves: Vec::new(),\n            });\n            continue;\n        }\n\n        if let Some(captures) = move_re.captures(line) {\n            if let Some(batch) = current.as_mut() {\n                batch.moves.push(ClusterMove {\n                    function: captures[1].to_string(),\n                    from: PathBuf::from(&captures[2]),\n                });\n            }\n        }\n    }\n\n    if let Some(batch) = current {\n        batches.push(batch);\n    }\n\n    Ok(batches)\n}\n\npub fn generate_phase2_cluster_slice(\n    plan_path: &Path,\n    batch_index: usize,\n    root: &Path,\n) -> std::io::Result<CorrectionIntelligenceReport> {\n    let batches = parse_phase2_cluster_plan(plan_path)?;\n    let batch = batches.get(batch_index.saturating_sub(1)).ok_or_else(|| {\n        std::io::Error::new(\n            std::io::ErrorKind::InvalidData,\n            format!(\"Batch {} not found in {:?}\", batch_index, plan_path),\n        )\n    })?;\n    if batch.moves.is_empty() {\n        return Err(std::io::Error::new(\n            std::io::ErrorKind::InvalidData,\n            format!(\n                \"Batch {} in {:?} has no move entries\",\n                batch_index, plan_path\n            ),\n        ));\n    }\n\n    let mut plans = Vec::new();\n    let mut policies = Vec::new();\n    let mut criteria = Vec::new();\n    let mut deltas = Vec::new();\n\n    for entry in &batch.moves {\n        let action = RefactorAction::MoveFunction {\n            function: entry.function.clone(),\n            from: entry.from.clone(),\n            to: batch.target.clone(),\n            required_layer: Some(batch.target.display().to_string()),\n        };\n        let predictions = vec![ViolationPrediction {\n            violation_type: ViolationType::LayerViolation,\n            affected_files: vec![entry.from.clone(), batch.target.clone()],\n            severity: Severity::Medium,\n            confidence: 0.6,\n        }];\n        let plan = generate_correction_plan(&action, &predictions);\n        let policy = plan_verification_scope(&action, &plan);\n        let rollback = build_rollback_criteria(&action, &plan);\n        let delta = QualityDelta {\n            action_id: plan.action_id.clone(),\n            cohesion_delta: 0.0,\n            violation_delta: 0,\n            complexity_delta: 0.0,\n            overall_score_delta: 0.0,\n            acceptable: true,\n            reason: \"Not estimated for cluster slice\".to_string(),\n        };\n        plans.push(plan);\n        policies.push(policy);\n        criteria.push(rollback);\n        deltas.push(delta);\n    }\n\n    let summary = compute_summary(&plans, &deltas);\n\n    Ok(CorrectionIntelligenceReport {\n        version: \"1.0\".to_string(),\n        timestamp: chrono::Utc::now().to_rfc3339(),\n        project_root: root.to_path_buf(),\n        actions_analyzed: plans.len(),\n        correction_plans: plans,\n        verification_policies: policies,\n        rollback_criteria: criteria,\n        quality_deltas: deltas,\n        summary,\n    })\n}\n\npub(crate) fn augment_path_coherence_strategies(\n    plan: &mut CorrectionPlan,\n    action: &RefactorAction,\n    root: &Path,\n) {\n    let RefactorAction::RenameFile { from, to } = action else {\n        return;\n    };\n    let Some(old_mod) = module_name_from_path(from) else {\n        return;\n    };\n    let Some(new_mod) = module_name_from_path(to) else {\n        return;\n    };\n    let old_file_name = from.file_name().and_then(|s| s.to_str()).unwrap_or(\"\");\n    let new_file_name = to.file_name().and_then(|s| s.to_str()).unwrap_or(\"\");\n    let replace_mod = old_mod != new_mod;\n\n    let mod_re = if replace_mod {\n        Regex::new(&format!(\n            r\"^\\s*(pub\\s+)?mod\\s+{}\\s*;\",\n            regex::escape(&old_mod)\n        ))\n        .ok()\n    } else {\n        None\n    };\n    let use_re = if replace_mod {\n        Regex::new(&format!(\n            r\"^\\s*use\\s+.*\\b{}\\b\",\n            regex::escape(&old_mod)\n        ))\n        .ok()\n    } else {\n        None\n    };\n    let path_re = if !old_file_name.is_empty() && !new_file_name.is_empty() {\n        Regex::new(r#\"^\\s*#\\s*\\[\\s*path\\s*=\\s*\"([^\"]+)\"\\s*\\]\"#).ok()\n    } else {\n        None\n    };\n\n    let mut updates = Vec::new();\n    let mut seen = HashSet::new();\n    let rust_files = crate::cluster_010::gather_rust_files(root);\n\n    for file in rust_files {\n        let Ok(contents) = fs::read_to_string(&file) else {\n            continue;\n        };\n        for line in contents.lines() {\n            if let Some(re) = &mod_re {\n                if re.is_match(line) {\n                    let new_line = line.replace(&old_mod, &new_mod);\n                    if new_line != line {\n                        let key = (file.clone(), line.to_string(), new_line.clone());\n                        if seen.insert(key.clone()) {\n                            updates.push(key);\n                        }\n                    }\n                    continue;\n                }\n            }\n            if let Some(re) = &use_re {\n                if re.is_match(line) {\n                    let new_line = line.replace(&old_mod, &new_mod);\n                    if new_line != line {\n                        let key = (file.clone(), line.to_string(), new_line.clone());\n                        if seen.insert(key.clone()) {\n                            updates.push(key);\n                        }\n                    }\n                    continue;\n                }\n            }\n            if let Some(re) = &path_re {\n                if re.is_match(line) && line.contains(old_file_name) {\n                    let new_line = line.replace(old_file_name, new_file_name);\n                    if new_line != line {\n                        let key = (file.clone(), line.to_string(), new_line.clone());\n                        if seen.insert(key.clone()) {\n                            updates.push(key);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    updates.sort_by(|a, b| {\n        a.0.cmp(&b.0)\n            .then_with(|| a.1.cmp(&b.1))\n            .then_with(|| a.2.cmp(&b.2))\n    });\n\n    for (file, old_ref, new_ref) in updates {\n        plan.strategies.push(CorrectionStrategy::UpdateCaller {\n            caller_file: file,\n            old_ref,\n            new_ref,\n        });\n    }\n}\n\nfn module_name_from_path(path: &Path) -> Option<String> {\n    let stem = path.file_stem().and_then(|s| s.to_str())?;\n    let name = if stem == \"mod\" {\n        path.parent()\n            .and_then(|p| p.file_name())\n            .and_then(|n| n.to_str())?\n            .to_string()\n    } else {\n        stem.to_string()\n    };\n    Some(crate::cluster_010::normalize_module_name(&name))\n}\n\n\n\n\n\npub(crate) fn compute_summary(plans: &[CorrectionPlan], deltas: &[QualityDelta]) -> CorrectionSummary {\n    let mut trivial = 0;\n    let mut moderate = 0;\n    let mut complex = 0;\n    let mut total_violations = 0;\n    let mut total_confidence = 0.0;\n    let mut total_time = 0;\n\n    for plan in plans {\n        match plan.tier {\n            ErrorTier::Trivial => trivial += 1,\n            ErrorTier::Moderate => moderate += 1,\n            ErrorTier::Complex => complex += 1,\n        }\n        total_violations += plan.predicted_violations.len();\n        total_confidence += plan.confidence;\n        total_time += plan.estimated_fix_time_seconds;\n    }\n\n    let avg_conf = if plans.is_empty() {\n        0.0\n    } else {\n        total_confidence / plans.len() as f64\n    };\n\n    let _ = deltas;\n\n    CorrectionSummary {\n        trivial_count: trivial,\n        moderate_count: moderate,\n        complex_count: complex,\n        total_predicted_violations: total_violations,\n        average_confidence: avg_conf,\n        estimated_total_fix_time_seconds: total_time,\n    }\n}\n\npub(crate) fn fill_prediction_confidence(predictions: &mut [ViolationPrediction]) {\n    for prediction in predictions {\n        if prediction.confidence <= 0.0 {\n            prediction.confidence = default_confidence(&prediction.violation_type);\n        }\n    }\n}\n\nfn default_confidence(violation_type: &crate::correction_plan_types::ViolationType) -> f64 {\n    match violation_type {\n        crate::correction_plan_types::ViolationType::UnresolvedImport => 0.95,\n        crate::correction_plan_types::ViolationType::NameCollision => 1.0,\n        crate::correction_plan_types::ViolationType::LayerViolation => 0.9,\n        crate::correction_plan_types::ViolationType::VisibilityMismatch => 0.8,\n        crate::correction_plan_types::ViolationType::BrokenReference => 0.85,\n        crate::correction_plan_types::ViolationType::TypeMismatch => 0.6,\n        crate::correction_plan_types::ViolationType::OwnershipIssue => 0.5,\n    }\n}\n\npub fn calculate_quality_delta(\n    action: &RefactorAction,\n    current: &Metrics,\n    simulated: &Metrics,\n) -> QualityDelta {\n    let cohesion_delta = simulated.cohesion - current.cohesion;\n    let violation_delta = simulated.violations as i32 - current.violations as i32;\n    let complexity_delta = simulated.complexity - current.complexity;\n    let overall = 0.5 * cohesion_delta - 0.3 * violation_delta as f64 - 0.2 * complexity_delta;\n    let acceptable = overall > -0.05 && violation_delta <= 0;\n    let reason = if acceptable {\n        \"Quality improved or maintained\".to_string()\n    } else if overall < -0.1 {\n        \"Quality degradation exceeds threshold\".to_string()\n    } else if violation_delta > 0 {\n        format!(\"Introduced {} new violations\", violation_delta)\n    } else {\n        \"Quality barely acceptable\".to_string()\n    };\n    QualityDelta {\n        action_id: action.action_id(),\n        cohesion_delta,\n        violation_delta,\n        complexity_delta,\n        overall_score_delta: overall,\n        acceptable,\n        reason,\n    }\n}\n\npub(crate) fn action_function(action: &RefactorAction) -> Option<String> {\n    match action {\n        RefactorAction::MoveFunction { function, .. } => Some(function.clone()),\n        _ => None,\n    }\n}\n\npub(crate) fn find_element_file(function: &str, elements: &[CodeElement]) -> Option<PathBuf> {\n    elements\n        .iter()\n        .find(|el| el.name == function)\n        .map(|el| PathBuf::from(&el.file_path))\n}\n\npub(crate) fn symbol_exists(symbol: &str, elements: &[CodeElement]) -> bool {\n    elements.iter().any(|el| el.name == symbol)\n}\n\npub(crate) fn move_violates_invariant(\n    _function: &str,\n    _from: &PathBuf,\n    _to: &PathBuf,\n    _invariants: &InvariantAnalysisResult,\n) -> bool {\n    false\n}\n\npub(crate) fn average_confidence(predictions: &[ViolationPrediction]) -> f64 {\n    if predictions.is_empty() {\n        return 1.0;\n    }\n    let total: f64 = predictions.iter().map(|p| p.confidence).sum();\n    total / predictions.len() as f64\n}\n\npub(crate) fn estimate_fix_time(count: usize) -> u32 {\n    10 + (count as u32 * 5)\n}\n\npub(crate) fn action_symbol(action: &RefactorAction) -> Option<String> {\n    match action {\n        RefactorAction::MoveFunction { function, .. } => Some(function.clone()),\n        RefactorAction::RenameFunction { new_name, .. } => Some(new_name.clone()),\n        RefactorAction::AdjustVisibility { symbol, .. } => Some(symbol.clone()),\n        _ => None,\n    }\n}\n\npub(crate) fn action_module_path(action: &RefactorAction) -> String {\n    match action {\n        RefactorAction::MoveFunction { to, .. } => to.display().to_string(),\n        RefactorAction::RenameFile { to, .. } => to.display().to_string(),\n        RefactorAction::CreateFile { path } => path.display().to_string(),\n        RefactorAction::AdjustVisibility { file, .. } => file.display().to_string(),\n        _ => \"crate\".to_string(),\n    }\n}\n\npub(crate) fn action_refs(action: &RefactorAction) -> Option<(String, String)> {\n    match action {\n        RefactorAction::RenameFunction { old_name, new_name, .. } => {\n            Some((old_name.clone(), new_name.clone()))\n        }\n        RefactorAction::RenameFile { from, to } => {\n            Some((from.display().to_string(), to.display().to_string()))\n        }\n        _ => None,\n    }\n}\n\npub(crate) fn action_target_layer(action: &RefactorAction) -> Option<String> {\n    match action {\n        RefactorAction::MoveFunction { required_layer, .. } => required_layer.clone(),\n        _ => None,\n    }\n}\n\npub(crate) fn action_visibility(\n    action: &RefactorAction,\n) -> Option<(\n    String,\n    std::path::PathBuf,\n    crate::types::Visibility,\n    crate::types::Visibility,\n    String,\n)> {\n    match action {\n        RefactorAction::AdjustVisibility {\n            symbol,\n            file,\n            from,\n            to,\n            reason,\n        } => Some((symbol.clone(), file.clone(), from.clone(), to.clone(), reason.clone())),\n        _ => None,\n    }\n}\n\npub(crate) fn affected_files(action: &RefactorAction) -> Vec<std::path::PathBuf> {\n    match action {\n        RefactorAction::MoveFunction { from, to, .. } => vec![from.clone(), to.clone()],\n        RefactorAction::RenameFunction { file, .. } => vec![file.clone()],\n        RefactorAction::RenameFile { from, to } => vec![from.clone(), to.clone()],\n        RefactorAction::CreateFile { path } => vec![path.clone()],\n        RefactorAction::AdjustVisibility { file, .. } => vec![file.clone()],\n    }\n}\n\npub(crate) fn action_module(action: &RefactorAction) -> String {\n    match action {\n        RefactorAction::MoveFunction { to, .. } => to.display().to_string(),\n        RefactorAction::RenameFunction { file, .. } => file.display().to_string(),\n        RefactorAction::RenameFile { to, .. } => to.display().to_string(),\n        RefactorAction::CreateFile { path } => path.display().to_string(),\n        RefactorAction::AdjustVisibility { file, .. } => file.display().to_string(),\n    }\n}\n\npub(crate) fn estimate_verification_time(tier: &ErrorTier) -> u32 {\n    match tier {\n        ErrorTier::Trivial => 10,\n        ErrorTier::Moderate => 60,\n        ErrorTier::Complex => 180,\n    }\n}\n\npub(crate) fn extract_critical_tests(_action: &RefactorAction) -> Vec<String> {\n    Vec::new()\n}\n\npub(crate) fn find_callers(\n    function: &str,\n    call_graph: &HashMap<String, CallGraphNode>,\n    elements: &[CodeElement],\n) -> Vec<PathBuf> {\n    let mut files = HashSet::new();\n    if let Some(node) = call_graph.get(function) {\n        for caller in &node.called_by {\n            if let Some(file) = find_element_file(caller, elements) {\n                files.insert(file);\n            }\n        }\n    }\n    files.into_iter().collect()\n}\n\npub(crate) fn find_reference_files(\n    function: &str,\n    call_graph: &HashMap<String, CallGraphNode>,\n    elements: &[CodeElement],\n) -> Vec<PathBuf> {\n    let mut files = HashSet::new();\n    for (caller, node) in call_graph {\n        if node.calls.iter().any(|c| c == function) {\n            if let Some(file) = find_element_file(caller, elements) {\n                files.insert(file);\n            }\n        }\n    }\n    files.into_iter().collect()\n}\n\npub(crate) fn simulate_action(_action: &RefactorAction, state: &AnalysisState) -> AnalysisState {\n    state.clone()\n}\n\npub fn predict_violations(\n    action: &RefactorAction,\n    invariants: &InvariantAnalysisResult,\n    call_graph: &HashMap<String, CallGraphNode>,\n    elements: &[CodeElement],\n) -> Vec<ViolationPrediction> {\n    let mut predictions = Vec::new();\n    match action {\n        RefactorAction::MoveFunction { function, from, to, required_layer } => {\n            let callers = find_callers(function, call_graph, elements);\n            if !callers.is_empty() {\n                predictions.push(ViolationPrediction {\n                    violation_type: ViolationType::UnresolvedImport,\n                    affected_files: callers,\n                    severity: Severity::Critical,\n                    confidence: 0.95,\n                });\n            }\n            if let Some(layer) = required_layer {\n                if !layer.is_empty() {\n                    predictions.push(ViolationPrediction {\n                        violation_type: ViolationType::LayerViolation,\n                        affected_files: vec![to.clone()],\n                        severity: Severity::High,\n                        confidence: 1.0,\n                    });\n                }\n            } else if move_violates_invariant(function, from, to, invariants) {\n                predictions.push(ViolationPrediction {\n                    violation_type: ViolationType::LayerViolation,\n                    affected_files: vec![to.clone()],\n                    severity: Severity::High,\n                    confidence: 0.9,\n                });\n            }\n        }\n        RefactorAction::RenameFunction { old_name, new_name, file } => {\n            if symbol_exists(new_name, elements) {\n                predictions.push(ViolationPrediction {\n                    violation_type: ViolationType::NameCollision,\n                    affected_files: vec![file.clone()],\n                    severity: Severity::Critical,\n                    confidence: 1.0,\n                });\n            }\n            let references = find_reference_files(old_name, call_graph, elements);\n            if !references.is_empty() {\n                predictions.push(ViolationPrediction {\n                    violation_type: ViolationType::BrokenReference,\n                    affected_files: references,\n                    severity: Severity::Critical,\n                    confidence: 0.85,\n                });\n            }\n        }\n        RefactorAction::RenameFile { from, to } => {\n            predictions.push(ViolationPrediction {\n                violation_type: ViolationType::BrokenReference,\n                affected_files: vec![from.clone(), to.clone()],\n                severity: Severity::High,\n                confidence: 0.7,\n            });\n        }\n        RefactorAction::CreateFile { path } => {\n            predictions.push(ViolationPrediction {\n                violation_type: ViolationType::UnresolvedImport,\n                affected_files: vec![path.clone()],\n                severity: Severity::Low,\n                confidence: 0.5,\n            });\n        }\n        RefactorAction::AdjustVisibility { file, .. } => {\n            predictions.push(ViolationPrediction {\n                violation_type: ViolationType::VisibilityMismatch,\n                affected_files: vec![file.clone()],\n                severity: Severity::Low,\n                confidence: 0.8,\n            });\n        }\n    }\n    predictions\n}\n\npub fn generate_correction_plan(\n    action: &RefactorAction,\n    predictions: &[ViolationPrediction],\n) -> CorrectionPlan {\n    let mut strategies = Vec::new();\n    for prediction in predictions {\n        match prediction.violation_type {\n            ViolationType::UnresolvedImport => {\n                if let Some(symbol) = action_symbol(action) {\n                    strategies.push(CorrectionStrategy::AddImport {\n                        module_path: action_module_path(action),\n                        symbol,\n                    });\n                }\n            }\n            ViolationType::BrokenReference => {\n                match action {\n                    RefactorAction::RenameFile { .. } => {\n                        if let Some((old_ref, new_ref)) = action_refs(action) {\n                            strategies.push(CorrectionStrategy::UpdatePath {\n                                old_path: old_ref,\n                                new_path: new_ref,\n                            });\n                        }\n                    }\n                    _ => {\n                        if let Some((old_ref, new_ref)) = action_refs(action) {\n                            for file in &prediction.affected_files {\n                                strategies.push(CorrectionStrategy::UpdateCaller {\n                                    caller_file: file.clone(),\n                                    old_ref: old_ref.clone(),\n                                    new_ref: new_ref.clone(),\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            ViolationType::NameCollision => {\n                if let Some(symbol) = action_symbol(action) {\n                    strategies.push(CorrectionStrategy::RenameWithSuffix {\n                        original: symbol,\n                        suffix: \"_v2\".to_string(),\n                    });\n                }\n            }\n            ViolationType::LayerViolation => {\n                if let Some(layer) = action_target_layer(action) {\n                    if let Some(function) = action_function(action) {\n                        strategies.push(CorrectionStrategy::MoveToLayer {\n                            function,\n                            target_layer: layer,\n                        });\n                        if let Some(function) = action_function(action) {\n                            if let Some(layer) = action_target_layer(action) {\n                                strategies.push(CorrectionStrategy::EnsureImports {\n                                    function,\n                                    target_layer: layer,\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            ViolationType::VisibilityMismatch => {\n                if let Some((symbol, file, from, to, reason)) = action_visibility(action) {\n                    if from == to || reason.starts_with(\"review:\") {\n                        let options = vec![\n                            VisibilityPlanOption {\n                                policy: \"keep_public\".to_string(),\n                                target: crate::types::Visibility::Public,\n                                requires_consent: false,\n                                description: \"Keep public (treat as external API).\".to_string(),\n                            },\n                            VisibilityPlanOption {\n                                policy: \"downgrade_pub_crate\".to_string(),\n                                target: crate::types::Visibility::Crate,\n                                requires_consent: true,\n                                description:\n                                    \"Narrow to pub(crate) (internal API only).\".to_string(),\n                            },\n                            VisibilityPlanOption {\n                                policy: \"downgrade_private\".to_string(),\n                                target: crate::types::Visibility::Private,\n                                requires_consent: true,\n                                description: \"Narrow to private (file-local).\".to_string(),\n                            },\n                        ];\n                        strategies.push(CorrectionStrategy::VisibilityPlan {\n                            symbol,\n                            file,\n                            current: from,\n                            default_policy: \"review_only\".to_string(),\n                            options,\n                            notes: reason,\n                        });\n                    } else {\n                        strategies.push(CorrectionStrategy::AdjustVisibility {\n                            symbol,\n                            file,\n                            from,\n                            to,\n                            reason,\n                        });\n                    }\n                }\n            }\n            ViolationType::TypeMismatch | ViolationType::OwnershipIssue => {\n                strategies.push(CorrectionStrategy::ManualReview {\n                    reason: format!(\"{:?} requires semantic analysis\", prediction.violation_type),\n                    context: format!(\"{:?}\", action),\n                });\n            }\n        }\n    }\n\n    let tier = predictions\n        .iter()\n        .map(classify_tier)\n        .max()\n        .unwrap_or(ErrorTier::Trivial);\n\n    CorrectionPlan {\n        action_id: action.action_id(),\n        tier,\n        predicted_violations: predictions.to_vec(),\n        strategies,\n        confidence: average_confidence(predictions),\n        estimated_fix_time_seconds: estimate_fix_time(predictions.len()),\n    }\n}\n\npub fn plan_verification_scope(\n    action: &RefactorAction,\n    correction_plan: &CorrectionPlan,\n) -> VerificationPolicy {\n    let scope = match correction_plan.tier {\n        ErrorTier::Trivial if correction_plan.predicted_violations.len() <= 3 => {\n            VerificationScope::SyntaxOnly {\n                files: affected_files(action),\n            }\n        }\n        ErrorTier::Trivial | ErrorTier::Moderate => VerificationScope::ModuleLocal {\n            module: action_module(action),\n            transitive_depth: 2,\n        },\n        ErrorTier::Complex => VerificationScope::FullWorkspace,\n    };\n\n    let mut required_checks = vec![VerificationCheck::CargoCheck];\n    if matches!(correction_plan.tier, ErrorTier::Moderate | ErrorTier::Complex) {\n        required_checks.push(VerificationCheck::CargoTest { filter: None });\n    }\n\n    VerificationPolicy {\n        action_id: correction_plan.action_id.clone(),\n        scope,\n        required_checks,\n        incremental_eligible: matches!(correction_plan.tier, ErrorTier::Trivial),\n        estimated_time_seconds: estimate_verification_time(&correction_plan.tier),\n    }\n}\n\npub fn build_rollback_criteria(\n    action: &RefactorAction,\n    correction_plan: &CorrectionPlan,\n) -> RollbackCriteria {\n    let mut mandatory = vec![RollbackCondition::BuildFailed];\n    let mut suggested = vec![RollbackCondition::QualityDecreased { threshold: 0.05 }];\n\n    match correction_plan.tier {\n        ErrorTier::Complex => {\n            mandatory.push(RollbackCondition::Tier3Error {\n                error_type: ViolationType::TypeMismatch,\n            });\n            mandatory.push(RollbackCondition::ManualReviewRequired);\n        }\n        ErrorTier::Moderate => {\n            suggested.push(RollbackCondition::TestsFailed {\n                critical_tests: extract_critical_tests(action),\n            });\n        }\n        ErrorTier::Trivial => {}\n    }\n\n    for prediction in &correction_plan.predicted_violations {\n        if prediction.violation_type == ViolationType::LayerViolation {\n            mandatory.push(RollbackCondition::InvariantViolated {\n                invariant_ids: vec![\"layer_ordering\".to_string()],\n            });\n        }\n    }\n\n    RollbackCriteria {\n        action_id: correction_plan.action_id.clone(),\n        mandatory_rollback_if: mandatory,\n        suggested_rollback_if: suggested,\n    }\n}\n\npub fn estimate_impact(action: &RefactorAction, current_state: &AnalysisState) -> QualityDelta {\n    let simulated = simulate_action(action, current_state);\n    calculate_quality_delta(action, &current_state.metrics, &simulated.metrics)\n}\n",
          "updated_content": "#![allow(dead_code)]\n//! Correction intelligence report generator.\n\nuse crate::correction_plan_types::{\n    CorrectionPlan,\n    CorrectionStrategy,\n    ErrorTier,\n    RefactorAction,\n    Severity,\n    ViolationPrediction,\n    ViolationType,\n};\nuse crate::quality_delta_calculator::Metrics;\nuse crate::quality_delta_types::{QualityDelta, RollbackCriteria};\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse std::{collections::HashSet, fs};\n\nuse crate::invariant_types::InvariantAnalysisResult;\nuse crate::types::{AnalysisResult, CallGraphNode, CodeElement};\nuse crate::action_impact_estimator::AnalysisState as ImpactState;\n\n#[allow(unused_imports)] pub use crate::correction_plan_serializer::write_intelligence_outputs_at;\nuse crate::action_impact_estimator::AnalysisState;\nuse crate::correction_plan_types::VisibilityPlanOption;\nuse crate::tier_classifier::classify_tier;\nuse crate::verification_policy_types::VerificationCheck;\nuse crate::verification_policy_types::VerificationPolicy;\nuse crate::verification_policy_types::VerificationScope;\nuse crate::quality_delta_types::RollbackCondition;\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct CorrectionIntelligenceReport {\n    pub version: String,\n    pub timestamp: String,\n    pub project_root: PathBuf,\n    pub actions_analyzed: usize,\n    pub correction_plans: Vec<CorrectionPlan>,\n    pub verification_policies: Vec<crate::verification_policy_types::VerificationPolicy>,\n    pub rollback_criteria: Vec<RollbackCriteria>,\n    pub quality_deltas: Vec<QualityDelta>,\n    pub summary: CorrectionSummary,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct CorrectionSummary {\n    pub trivial_count: usize,\n    pub moderate_count: usize,\n    pub complex_count: usize,\n    pub total_predicted_violations: usize,\n    pub average_confidence: f64,\n    pub estimated_total_fix_time_seconds: u32,\n}\n\n#[derive(Clone, Debug)]\npub struct IntelligenceState<'a> {\n    pub root: PathBuf,\n    pub invariants: &'a InvariantAnalysisResult,\n    pub call_graph: &'a HashMap<String, CallGraphNode>,\n    pub elements: &'a [CodeElement],\n    pub metrics: Metrics,\n}\n\npub fn build_state<'a>(\n    root: &'a Path,\n    analysis: &'a AnalysisResult,\n    metrics: Metrics,\n) -> IntelligenceState<'a> {\n    IntelligenceState {\n        root: root.to_path_buf(),\n        invariants: &analysis.invariants,\n        call_graph: &analysis.call_graph,\n        elements: &analysis.elements,\n        metrics,\n    }\n}\n\n\n\npub fn write_intelligence_outputs(\n    report: &CorrectionIntelligenceReport,\n    output_dir: &Path,\n) -> std::io::Result<()> {\n    write_intelligence_outputs_at(report, output_dir, None, None)\n}\n\npub fn filter_path_coherence_report(\n    report: &CorrectionIntelligenceReport,\n) -> CorrectionIntelligenceReport {\n    let mut plans = Vec::new();\n    let mut policies = Vec::new();\n    let mut criteria = Vec::new();\n    let mut deltas = Vec::new();\n\n    for (idx, plan) in report.correction_plans.iter().enumerate() {\n        let mut has_path_coherence = false;\n        for strategy in &plan.strategies {\n            match strategy {\n                CorrectionStrategy::UpdatePath { .. } => {\n                    has_path_coherence = true;\n                    break;\n                }\n                CorrectionStrategy::UpdateCaller { old_ref, .. } => {\n                    let trimmed = old_ref.trim_start();\n                    if trimmed.starts_with(\"mod \")\n                        || trimmed.starts_with(\"pub mod \")\n                        || trimmed.starts_with(\"use \")\n                        || trimmed.starts_with(\"#[path\")\n                    {\n                        has_path_coherence = true;\n                        break;\n                    }\n                }\n                _ => {}\n            }\n        }\n        let is_rename_file = plan.action_id.starts_with(\"rename_file_\");\n\n        if !(has_path_coherence || is_rename_file) {\n            continue;\n        }\n\n        plans.push(plan.clone());\n        if let Some(policy) = report.verification_policies.get(idx) {\n            policies.push(policy.clone());\n        }\n        if let Some(rollback) = report.rollback_criteria.get(idx) {\n            criteria.push(rollback.clone());\n        }\n        if let Some(delta) = report.quality_deltas.get(idx) {\n            deltas.push(delta.clone());\n        }\n    }\n\n    let summary = compute_summary(&plans, &deltas);\n\n    CorrectionIntelligenceReport {\n        version: report.version.clone(),\n        timestamp: report.timestamp.clone(),\n        project_root: report.project_root.clone(),\n        actions_analyzed: plans.len(),\n        correction_plans: plans,\n        verification_policies: policies,\n        rollback_criteria: criteria,\n        quality_deltas: deltas,\n        summary,\n    }\n}\n\npub fn filter_visibility_report(\n    report: &CorrectionIntelligenceReport,\n) -> CorrectionIntelligenceReport {\n    let mut plans = Vec::new();\n    let mut policies = Vec::new();\n    let mut criteria = Vec::new();\n    let mut deltas = Vec::new();\n\n    for (idx, plan) in report.correction_plans.iter().enumerate() {\n        let mut has_visibility = false;\n        for strategy in &plan.strategies {\n            match strategy {\n                CorrectionStrategy::AdjustVisibility { .. } => {\n                    has_visibility = true;\n                    break;\n                }\n                CorrectionStrategy::VisibilityPlan { .. } => {\n                    has_visibility = true;\n                    break;\n                }\n                CorrectionStrategy::ManualReview { reason, .. }\n                    if reason.starts_with(\"review:\") =>\n                {\n                    has_visibility = true;\n                    break;\n                }\n                _ => {}\n            }\n        }\n        if !has_visibility {\n            continue;\n        }\n        plans.push(plan.clone());\n        if let Some(policy) = report.verification_policies.get(idx) {\n            policies.push(policy.clone());\n        }\n        if let Some(rollback) = report.rollback_criteria.get(idx) {\n            criteria.push(rollback.clone());\n        }\n        if let Some(delta) = report.quality_deltas.get(idx) {\n            deltas.push(delta.clone());\n        }\n    }\n\n    let summary = compute_summary(&plans, &deltas);\n\n    CorrectionIntelligenceReport {\n        version: report.version.clone(),\n        timestamp: report.timestamp.clone(),\n        project_root: report.project_root.clone(),\n        actions_analyzed: plans.len(),\n        correction_plans: plans,\n        verification_policies: policies,\n        rollback_criteria: criteria,\n        quality_deltas: deltas,\n        summary,\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct ClusterMove {\n    function: String,\n    from: PathBuf,\n}\n\n#[derive(Clone, Debug)]\nstruct ClusterBatch {\n    target: PathBuf,\n    moves: Vec<ClusterMove>,\n}\n\nfn parse_phase2_cluster_plan(plan_path: &Path) -> std::io::Result<Vec<ClusterBatch>> {\n    let contents = fs::read_to_string(plan_path)?;\n    let batch_re =\n        Regex::new(r\"^#### Batch \\d+: target `([^`]+)`\").map_err(|err| {\n            std::io::Error::new(std::io::ErrorKind::InvalidData, err.to_string())\n        })?;\n    let move_re = Regex::new(r\"^- Move `([^`]+)` from `([^`]+)`\").map_err(|err| {\n        std::io::Error::new(std::io::ErrorKind::InvalidData, err.to_string())\n    })?;\n    let mut batches = Vec::new();\n    let mut current: Option<ClusterBatch> = None;\n\n    for line in contents.lines() {\n        if let Some(captures) = batch_re.captures(line) {\n            if let Some(batch) = current.take() {\n                batches.push(batch);\n            }\n            current = Some(ClusterBatch {\n                target: PathBuf::from(&captures[1]),\n                moves: Vec::new(),\n            });\n            continue;\n        }\n\n        if let Some(captures) = move_re.captures(line) {\n            if let Some(batch) = current.as_mut() {\n                batch.moves.push(ClusterMove {\n                    function: captures[1].to_string(),\n                    from: PathBuf::from(&captures[2]),\n                });\n            }\n        }\n    }\n\n    if let Some(batch) = current {\n        batches.push(batch);\n    }\n\n    Ok(batches)\n}\n\npub fn generate_phase2_cluster_slice(\n    plan_path: &Path,\n    batch_index: usize,\n    root: &Path,\n) -> std::io::Result<CorrectionIntelligenceReport> {\n    let batches = parse_phase2_cluster_plan(plan_path)?;\n    let batch = batches.get(batch_index.saturating_sub(1)).ok_or_else(|| {\n        std::io::Error::new(\n            std::io::ErrorKind::InvalidData,\n            format!(\"Batch {} not found in {:?}\", batch_index, plan_path),\n        )\n    })?;\n    if batch.moves.is_empty() {\n        return Err(std::io::Error::new(\n            std::io::ErrorKind::InvalidData,\n            format!(\n                \"Batch {} in {:?} has no move entries\",\n                batch_index, plan_path\n            ),\n        ));\n    }\n\n    let mut plans = Vec::new();\n    let mut policies = Vec::new();\n    let mut criteria = Vec::new();\n    let mut deltas = Vec::new();\n\n    for entry in &batch.moves {\n        let action = RefactorAction::MoveFunction {\n            function: entry.function.clone(),\n            from: entry.from.clone(),\n            to: batch.target.clone(),\n            required_layer: Some(batch.target.display().to_string()),\n        };\n        let predictions = vec![ViolationPrediction {\n            violation_type: ViolationType::LayerViolation,\n            affected_files: vec![entry.from.clone(), batch.target.clone()],\n            severity: Severity::Medium,\n            confidence: 0.6,\n        }];\n        let plan = generate_correction_plan(&action, &predictions);\n        let policy = plan_verification_scope(&action, &plan);\n        let rollback = build_rollback_criteria(&action, &plan);\n        let delta = QualityDelta {\n            action_id: plan.action_id.clone(),\n            cohesion_delta: 0.0,\n            violation_delta: 0,\n            complexity_delta: 0.0,\n            overall_score_delta: 0.0,\n            acceptable: true,\n            reason: \"Not estimated for cluster slice\".to_string(),\n        };\n        plans.push(plan);\n        policies.push(policy);\n        criteria.push(rollback);\n        deltas.push(delta);\n    }\n\n    let summary = compute_summary(&plans, &deltas);\n\n    Ok(CorrectionIntelligenceReport {\n        version: \"1.0\".to_string(),\n        timestamp: chrono::Utc::now().to_rfc3339(),\n        project_root: root.to_path_buf(),\n        actions_analyzed: plans.len(),\n        correction_plans: plans,\n        verification_policies: policies,\n        rollback_criteria: criteria,\n        quality_deltas: deltas,\n        summary,\n    })\n}\n\npub(crate) fn augment_path_coherence_strategies(\n    plan: &mut CorrectionPlan,\n    action: &RefactorAction,\n    root: &Path,\n) {\n    let RefactorAction::RenameFile { from, to } = action else {\n        return;\n    };\n    let Some(old_mod) = module_name_from_path(from) else {\n        return;\n    };\n    let Some(new_mod) = module_name_from_path(to) else {\n        return;\n    };\n    let old_file_name = from.file_name().and_then(|s| s.to_str()).unwrap_or(\"\");\n    let new_file_name = to.file_name().and_then(|s| s.to_str()).unwrap_or(\"\");\n    let replace_mod = old_mod != new_mod;\n\n    let mod_re = if replace_mod {\n        Regex::new(&format!(\n            r\"^\\s*(pub\\s+)?mod\\s+{}\\s*;\",\n            regex::escape(&old_mod)\n        ))\n        .ok()\n    } else {\n        None\n    };\n    let use_re = if replace_mod {\n        Regex::new(&format!(\n            r\"^\\s*use\\s+.*\\b{}\\b\",\n            regex::escape(&old_mod)\n        ))\n        .ok()\n    } else {\n        None\n    };\n    let path_re = if !old_file_name.is_empty() && !new_file_name.is_empty() {\n        Regex::new(r#\"^\\s*#\\s*\\[\\s*path\\s*=\\s*\"([^\"]+)\"\\s*\\]\"#).ok()\n    } else {\n        None\n    };\n\n    let mut updates = Vec::new();\n    let mut seen = HashSet::new();\n    let rust_files = crate::cluster_010::gather_rust_files(root);\n\n    for file in rust_files {\n        let Ok(contents) = fs::read_to_string(&file) else {\n            continue;\n        };\n        for line in contents.lines() {\n            if let Some(re) = &mod_re {\n                if re.is_match(line) {\n                    let new_line = line.replace(&old_mod, &new_mod);\n                    if new_line != line {\n                        let key = (file.clone(), line.to_string(), new_line.clone());\n                        if seen.insert(key.clone()) {\n                            updates.push(key);\n                        }\n                    }\n                    continue;\n                }\n            }\n            if let Some(re) = &use_re {\n                if re.is_match(line) {\n                    let new_line = line.replace(&old_mod, &new_mod);\n                    if new_line != line {\n                        let key = (file.clone(), line.to_string(), new_line.clone());\n                        if seen.insert(key.clone()) {\n                            updates.push(key);\n                        }\n                    }\n                    continue;\n                }\n            }\n            if let Some(re) = &path_re {\n                if re.is_match(line) && line.contains(old_file_name) {\n                    let new_line = line.replace(old_file_name, new_file_name);\n                    if new_line != line {\n                        let key = (file.clone(), line.to_string(), new_line.clone());\n                        if seen.insert(key.clone()) {\n                            updates.push(key);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    updates.sort_by(|a, b| {\n        a.0.cmp(&b.0)\n            .then_with(|| a.1.cmp(&b.1))\n            .then_with(|| a.2.cmp(&b.2))\n    });\n\n    for (file, old_ref, new_ref) in updates {\n        plan.strategies.push(CorrectionStrategy::UpdateCaller {\n            caller_file: file,\n            old_ref,\n            new_ref,\n        });\n    }\n}\n\nfn module_name_from_path(path: &Path) -> Option<String> {\n    let stem = path.file_stem().and_then(|s| s.to_str())?;\n    let name = if stem == \"mod\" {\n        path.parent()\n            .and_then(|p| p.file_name())\n            .and_then(|n| n.to_str())?\n            .to_string()\n    } else {\n        stem.to_string()\n    };\n    Some(crate::cluster_010::normalize_module_name(&name))\n}\n\n\n\n\n\npub(crate) fn compute_summary(plans: &[CorrectionPlan], deltas: &[QualityDelta]) -> CorrectionSummary {\n    let mut trivial = 0;\n    let mut moderate = 0;\n    let mut complex = 0;\n    let mut total_violations = 0;\n    let mut total_confidence = 0.0;\n    let mut total_time = 0;\n\n    for plan in plans {\n        match plan.tier {\n            ErrorTier::Trivial => trivial += 1,\n            ErrorTier::Moderate => moderate += 1,\n            ErrorTier::Complex => complex += 1,\n        }\n        total_violations += plan.predicted_violations.len();\n        total_confidence += plan.confidence;\n        total_time += plan.estimated_fix_time_seconds;\n    }\n\n    let avg_conf = if plans.is_empty() {\n        0.0\n    } else {\n        total_confidence / plans.len() as f64\n    };\n\n    let _ = deltas;\n\n    CorrectionSummary {\n        trivial_count: trivial,\n        moderate_count: moderate,\n        complex_count: complex,\n        total_predicted_violations: total_violations,\n        average_confidence: avg_conf,\n        estimated_total_fix_time_seconds: total_time,\n    }\n}\n\npub(crate) fn fill_prediction_confidence(predictions: &mut [ViolationPrediction]) {\n    for prediction in predictions {\n        if prediction.confidence <= 0.0 {\n            prediction.confidence = default_confidence(&prediction.violation_type);\n        }\n    }\n}\n\nfn default_confidence(violation_type: &crate::correction_plan_types::ViolationType) -> f64 {\n    match violation_type {\n        crate::correction_plan_types::ViolationType::UnresolvedImport => 0.95,\n        crate::correction_plan_types::ViolationType::NameCollision => 1.0,\n        crate::correction_plan_types::ViolationType::LayerViolation => 0.9,\n        crate::correction_plan_types::ViolationType::VisibilityMismatch => 0.8,\n        crate::correction_plan_types::ViolationType::BrokenReference => 0.85,\n        crate::correction_plan_types::ViolationType::TypeMismatch => 0.6,\n        crate::correction_plan_types::ViolationType::OwnershipIssue => 0.5,\n    }\n}\n\npub fn calculate_quality_delta(\n    action: &RefactorAction,\n    current: &Metrics,\n    simulated: &Metrics,\n) -> QualityDelta {\n    let cohesion_delta = simulated.cohesion - current.cohesion;\n    let violation_delta = simulated.violations as i32 - current.violations as i32;\n    let complexity_delta = simulated.complexity - current.complexity;\n    let overall = 0.5 * cohesion_delta - 0.3 * violation_delta as f64 - 0.2 * complexity_delta;\n    let acceptable = overall > -0.05 && violation_delta <= 0;\n    let reason = if acceptable {\n        \"Quality improved or maintained\".to_string()\n    } else if overall < -0.1 {\n        \"Quality degradation exceeds threshold\".to_string()\n    } else if violation_delta > 0 {\n        format!(\"Introduced {} new violations\", violation_delta)\n    } else {\n        \"Quality barely acceptable\".to_string()\n    };\n    QualityDelta {\n        action_id: action.action_id(),\n        cohesion_delta,\n        violation_delta,\n        complexity_delta,\n        overall_score_delta: overall,\n        acceptable,\n        reason,\n    }\n}\n\npub(crate) fn action_function(action: &RefactorAction) -> Option<String> {\n    match action {\n        RefactorAction::MoveFunction { function, .. } => Some(function.clone()),\n        _ => None,\n    }\n}\n\npub(crate) fn find_element_file(function: &str, elements: &[CodeElement]) -> Option<PathBuf> {\n    elements\n        .iter()\n        .find(|el| el.name == function)\n        .map(|el| PathBuf::from(&el.file_path))\n}\n\npub(crate) fn symbol_exists(symbol: &str, elements: &[CodeElement]) -> bool {\n    elements.iter().any(|el| el.name == symbol)\n}\n\npub(crate) fn move_violates_invariant(\n    _function: &str,\n    _from: &PathBuf,\n    _to: &PathBuf,\n    _invariants: &InvariantAnalysisResult,\n) -> bool {\n    false\n}\n\npub(crate) fn average_confidence(predictions: &[ViolationPrediction]) -> f64 {\n    if predictions.is_empty() {\n        return 1.0;\n    }\n    let total: f64 = predictions.iter().map(|p| p.confidence).sum();\n    total / predictions.len() as f64\n}\n\npub(crate) fn estimate_fix_time(count: usize) -> u32 {\n    10 + (count as u32 * 5)\n}\n\npub(crate) fn action_symbol(action: &RefactorAction) -> Option<String> {\n    match action {\n        RefactorAction::MoveFunction { function, .. } => Some(function.clone()),\n        RefactorAction::RenameFunction { new_name, .. } => Some(new_name.clone()),\n        RefactorAction::AdjustVisibility { symbol, .. } => Some(symbol.clone()),\n        _ => None,\n    }\n}\n\npub(crate) fn action_module_path(action: &RefactorAction) -> String {\n    match action {\n        RefactorAction::MoveFunction { to, .. } => to.display().to_string(),\n        RefactorAction::RenameFile { to, .. } => to.display().to_string(),\n        RefactorAction::CreateFile { path } => path.display().to_string(),\n        RefactorAction::AdjustVisibility { file, .. } => file.display().to_string(),\n        _ => \"crate\".to_string(),\n    }\n}\n\npub(crate) fn action_refs(action: &RefactorAction) -> Option<(String, String)> {\n    match action {\n        RefactorAction::RenameFunction { old_name, new_name, .. } => {\n            Some((old_name.clone(), new_name.clone()))\n        }\n        RefactorAction::RenameFile { from, to } => {\n            Some((from.display().to_string(), to.display().to_string()))\n        }\n        _ => None,\n    }\n}\n\npub(crate) fn action_target_layer(action: &RefactorAction) -> Option<String> {\n    match action {\n        RefactorAction::MoveFunction { required_layer, .. } => required_layer.clone(),\n        _ => None,\n    }\n}\n\npub(crate) fn action_visibility(\n    action: &RefactorAction,\n) -> Option<(\n    String,\n    std::path::PathBuf,\n    crate::types::Visibility,\n    crate::types::Visibility,\n    String,\n)> {\n    match action {\n        RefactorAction::AdjustVisibility {\n            symbol,\n            file,\n            from,\n            to,\n            reason,\n        } => Some((symbol.clone(), file.clone(), from.clone(), to.clone(), reason.clone())),\n        _ => None,\n    }\n}\n\npub(crate) fn affected_files(action: &RefactorAction) -> Vec<std::path::PathBuf> {\n    match action {\n        RefactorAction::MoveFunction { from, to, .. } => vec![from.clone(), to.clone()],\n        RefactorAction::RenameFunction { file, .. } => vec![file.clone()],\n        RefactorAction::RenameFile { from, to } => vec![from.clone(), to.clone()],\n        RefactorAction::CreateFile { path } => vec![path.clone()],\n        RefactorAction::AdjustVisibility { file, .. } => vec![file.clone()],\n    }\n}\n\npub(crate) fn action_module(action: &RefactorAction) -> String {\n    match action {\n        RefactorAction::MoveFunction { to, .. } => to.display().to_string(),\n        RefactorAction::RenameFunction { file, .. } => file.display().to_string(),\n        RefactorAction::RenameFile { to, .. } => to.display().to_string(),\n        RefactorAction::CreateFile { path } => path.display().to_string(),\n        RefactorAction::AdjustVisibility { file, .. } => file.display().to_string(),\n    }\n}\n\npub(crate) fn estimate_verification_time(tier: &ErrorTier) -> u32 {\n    match tier {\n        ErrorTier::Trivial => 10,\n        ErrorTier::Moderate => 60,\n        ErrorTier::Complex => 180,\n    }\n}\n\npub(crate) fn extract_critical_tests(_action: &RefactorAction) -> Vec<String> {\n    Vec::new()\n}\n\npub(crate) fn find_callers(\n    function: &str,\n    call_graph: &HashMap<String, CallGraphNode>,\n    elements: &[CodeElement],\n) -> Vec<PathBuf> {\n    let mut files = HashSet::new();\n    if let Some(node) = call_graph.get(function) {\n        for caller in &node.called_by {\n            if let Some(file) = find_element_file(caller, elements) {\n                files.insert(file);\n            }\n        }\n    }\n    files.into_iter().collect()\n}\n\npub(crate) fn find_reference_files(\n    function: &str,\n    call_graph: &HashMap<String, CallGraphNode>,\n    elements: &[CodeElement],\n) -> Vec<PathBuf> {\n    let mut files = HashSet::new();\n    for (caller, node) in call_graph {\n        if node.calls.iter().any(|c| c == function) {\n            if let Some(file) = find_element_file(caller, elements) {\n                files.insert(file);\n            }\n        }\n    }\n    files.into_iter().collect()\n}\n\npub(crate) fn simulate_action(_action: &RefactorAction, state: &AnalysisState) -> AnalysisState {\n    state.clone()\n}\n\npub fn predict_violations(\n    action: &RefactorAction,\n    invariants: &InvariantAnalysisResult,\n    call_graph: &HashMap<String, CallGraphNode>,\n    elements: &[CodeElement],\n) -> Vec<ViolationPrediction> {\n    let mut predictions = Vec::new();\n    match action {\n        RefactorAction::MoveFunction { function, from, to, required_layer } => {\n            let callers = find_callers(function, call_graph, elements);\n            if !callers.is_empty() {\n                predictions.push(ViolationPrediction {\n                    violation_type: ViolationType::UnresolvedImport,\n                    affected_files: callers,\n                    severity: Severity::Critical,\n                    confidence: 0.95,\n                });\n            }\n            if let Some(layer) = required_layer {\n                if !layer.is_empty() {\n                    predictions.push(ViolationPrediction {\n                        violation_type: ViolationType::LayerViolation,\n                        affected_files: vec![to.clone()],\n                        severity: Severity::High,\n                        confidence: 1.0,\n                    });\n                }\n            } else if move_violates_invariant(function, from, to, invariants) {\n                predictions.push(ViolationPrediction {\n                    violation_type: ViolationType::LayerViolation,\n                    affected_files: vec![to.clone()],\n                    severity: Severity::High,\n                    confidence: 0.9,\n                });\n            }\n        }\n        RefactorAction::RenameFunction { old_name, new_name, file } => {\n            if symbol_exists(new_name, elements) {\n                predictions.push(ViolationPrediction {\n                    violation_type: ViolationType::NameCollision,\n                    affected_files: vec![file.clone()],\n                    severity: Severity::Critical,\n                    confidence: 1.0,\n                });\n            }\n            let references = find_reference_files(old_name, call_graph, elements);\n            if !references.is_empty() {\n                predictions.push(ViolationPrediction {\n                    violation_type: ViolationType::BrokenReference,\n                    affected_files: references,\n                    severity: Severity::Critical,\n                    confidence: 0.85,\n                });\n            }\n        }\n        RefactorAction::RenameFile { from, to } => {\n            predictions.push(ViolationPrediction {\n                violation_type: ViolationType::BrokenReference,\n                affected_files: vec![from.clone(), to.clone()],\n                severity: Severity::High,\n                confidence: 0.7,\n            });\n        }\n        RefactorAction::CreateFile { path } => {\n            predictions.push(ViolationPrediction {\n                violation_type: ViolationType::UnresolvedImport,\n                affected_files: vec![path.clone()],\n                severity: Severity::Low,\n                confidence: 0.5,\n            });\n        }\n        RefactorAction::AdjustVisibility { file, .. } => {\n            predictions.push(ViolationPrediction {\n                violation_type: ViolationType::VisibilityMismatch,\n                affected_files: vec![file.clone()],\n                severity: Severity::Low,\n                confidence: 0.8,\n            });\n        }\n    }\n    predictions\n}\n\npub fn generate_correction_plan(\n    action: &RefactorAction,\n    predictions: &[ViolationPrediction],\n) -> CorrectionPlan {\n    let mut strategies = Vec::new();\n    for prediction in predictions {\n        match prediction.violation_type {\n            ViolationType::UnresolvedImport => {\n                if let Some(symbol) = action_symbol(action) {\n                    strategies.push(CorrectionStrategy::AddImport {\n                        module_path: action_module_path(action),\n                        symbol,\n                    });\n                }\n            }\n            ViolationType::BrokenReference => {\n                match action {\n                    RefactorAction::RenameFile { .. } => {\n                        if let Some((old_ref, new_ref)) = action_refs(action) {\n                            strategies.push(CorrectionStrategy::UpdatePath {\n                                old_path: old_ref,\n                                new_path: new_ref,\n                            });\n                        }\n                    }\n                    _ => {\n                        if let Some((old_ref, new_ref)) = action_refs(action) {\n                            for file in &prediction.affected_files {\n                                strategies.push(CorrectionStrategy::UpdateCaller {\n                                    caller_file: file.clone(),\n                                    old_ref: old_ref.clone(),\n                                    new_ref: new_ref.clone(),\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            ViolationType::NameCollision => {\n                if let Some(symbol) = action_symbol(action) {\n                    strategies.push(CorrectionStrategy::RenameWithSuffix {\n                        original: symbol,\n                        suffix: \"_v2\".to_string(),\n                    });\n                }\n            }\n            ViolationType::LayerViolation => {\n                if let Some(layer) = action_target_layer(action) {\n                    if let Some(function) = action_function(action) {\n                        strategies.push(CorrectionStrategy::MoveToLayer {\n                            function,\n                            target_layer: layer,\n                        });\n                        if let Some(function) = action_function(action) {\n                            if let Some(layer) = action_target_layer(action) {\n                                strategies.push(CorrectionStrategy::EnsureImports {\n                                    function,\n                                    target_layer: layer,\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            ViolationType::VisibilityMismatch => {\n                if let Some((symbol, file, from, to, reason)) = action_visibility(action) {\n                    if from == to || reason.starts_with(\"review:\") {\n                        let options = vec![\n                            VisibilityPlanOption {\n                                policy: \"keep_public\".to_string(),\n                                target: crate::types::Visibility::Public,\n                                requires_consent: false,\n                                description: \"Keep public (treat as external API).\".to_string(),\n                            },\n                            VisibilityPlanOption {\n                                policy: \"downgrade_pub_crate\".to_string(),\n                                target: crate::types::Visibility::Crate,\n                                requires_consent: true,\n                                description:\n                                    \"Narrow to pub(crate) (internal API only).\".to_string(),\n                            },\n                            VisibilityPlanOption {\n                                policy: \"downgrade_private\".to_string(),\n                                target: crate::types::Visibility::Private,\n                                requires_consent: true,\n                                description: \"Narrow to private (file-local).\".to_string(),\n                            },\n                        ];\n                        strategies.push(CorrectionStrategy::VisibilityPlan {\n                            symbol,\n                            file,\n                            current: from,\n                            default_policy: \"review_only\".to_string(),\n                            options,\n                            notes: reason,\n                        });\n                    } else {\n                        strategies.push(CorrectionStrategy::AdjustVisibility {\n                            symbol,\n                            file,\n                            from,\n                            to,\n                            reason,\n                        });\n                    }\n                }\n            }\n            ViolationType::TypeMismatch | ViolationType::OwnershipIssue => {\n                strategies.push(CorrectionStrategy::ManualReview {\n                    reason: format!(\"{:?} requires semantic analysis\", prediction.violation_type),\n                    context: format!(\"{:?}\", action),\n                });\n            }\n        }\n    }\n\n    let tier = predictions\n        .iter()\n        .map(classify_tier)\n        .max()\n        .unwrap_or(ErrorTier::Trivial);\n\n    CorrectionPlan {\n        action_id: action.action_id(),\n        tier,\n        predicted_violations: predictions.to_vec(),\n        strategies,\n        confidence: average_confidence(predictions),\n        estimated_fix_time_seconds: estimate_fix_time(predictions.len()),\n    }\n}\n\npub fn plan_verification_scope(\n    action: &RefactorAction,\n    correction_plan: &CorrectionPlan,\n) -> VerificationPolicy {\n    let scope = match correction_plan.tier {\n        ErrorTier::Trivial if correction_plan.predicted_violations.len() <= 3 => {\n            VerificationScope::SyntaxOnly {\n                files: affected_files(action),\n            }\n        }\n        ErrorTier::Trivial | ErrorTier::Moderate => VerificationScope::ModuleLocal {\n            module: action_module(action),\n            transitive_depth: 2,\n        },\n        ErrorTier::Complex => VerificationScope::FullWorkspace,\n    };\n\n    let mut required_checks = vec![VerificationCheck::CargoCheck];\n    if matches!(correction_plan.tier, ErrorTier::Moderate | ErrorTier::Complex) {\n        required_checks.push(VerificationCheck::CargoTest { filter: None });\n    }\n\n    VerificationPolicy {\n        action_id: correction_plan.action_id.clone(),\n        scope,\n        required_checks,\n        incremental_eligible: matches!(correction_plan.tier, ErrorTier::Trivial),\n        estimated_time_seconds: estimate_verification_time(&correction_plan.tier),\n    }\n}\n\npub fn build_rollback_criteria(\n    action: &RefactorAction,\n    correction_plan: &CorrectionPlan,\n) -> RollbackCriteria {\n    let mut mandatory = vec![RollbackCondition::BuildFailed];\n    let mut suggested = vec![RollbackCondition::QualityDecreased { threshold: 0.05 }];\n\n    match correction_plan.tier {\n        ErrorTier::Complex => {\n            mandatory.push(RollbackCondition::Tier3Error {\n                error_type: ViolationType::TypeMismatch,\n            });\n            mandatory.push(RollbackCondition::ManualReviewRequired);\n        }\n        ErrorTier::Moderate => {\n            suggested.push(RollbackCondition::TestsFailed {\n                critical_tests: extract_critical_tests(action),\n            });\n        }\n        ErrorTier::Trivial => {}\n    }\n\n    for prediction in &correction_plan.predicted_violations {\n        if prediction.violation_type == ViolationType::LayerViolation {\n            mandatory.push(RollbackCondition::InvariantViolated {\n                invariant_ids: vec![\"layer_ordering\".to_string()],\n            });\n        }\n    }\n\n    RollbackCriteria {\n        action_id: correction_plan.action_id.clone(),\n        mandatory_rollback_if: mandatory,\n        suggested_rollback_if: suggested,\n    }\n}\n\npub fn estimate_impact(action: &RefactorAction, current_state: &AnalysisState) -> QualityDelta {\n    let simulated = simulate_action(action, current_state);\n    calculate_quality_delta(action, &current_state.metrics, &simulated.metrics)\n}\n\npub fn generate_intelligence_report(\n    actions: &[RefactorAction],\n    state: &IntelligenceState<'_>,\n) -> CorrectionIntelligenceReport {\n    let mut plans = Vec::new();\n    let mut policies = Vec::new();\n    let mut criteria = Vec::new();\n    let mut deltas = Vec::new();\n\n    for action in actions {\n        let mut predictions =\n            predict_violations(action, state.invariants, state.call_graph, state.elements);\n        fill_prediction_confidence(&mut predictions);\n        let mut plan = generate_correction_plan(action, &predictions);\n        augment_path_coherence_strategies(&mut plan, action, &state.root);\n        let policy = plan_verification_scope(action, &plan);\n        let rollback = build_rollback_criteria(action, &plan);\n        let delta = estimate_impact(action, &ImpactState {\n            metrics: state.metrics.clone(),\n        });\n\n        plans.push(plan);\n        policies.push(policy);\n        criteria.push(rollback);\n        deltas.push(delta);\n    }\n\n    let summary = compute_summary(&plans, &deltas);\n\n    CorrectionIntelligenceReport {\n        version: \"1.0\".to_string(),\n        timestamp: chrono::Utc::now().to_rfc3339(),\n        project_root: state.root.clone(),\n        actions_analyzed: actions.len(),\n        correction_plans: plans,\n        verification_policies: policies,\n        rollback_criteria: criteria,\n        quality_deltas: deltas,\n        summary,\n    }\n}\n"
        }
      ],
      "applied": false,
      "errors": []
    }
  ]
}