# T0.2: Recompute Dependency Contract Verification

**Status:** ✅ Verified  
**Date:** 2025-12-17

## Task

Verify current `register_passthrough_recompute!` implementation is pure and documents the contract.

## Mathematical Contract

$$R_p(s, p) : \text{State} \times \text{Page} \to \mathbb{B}^n$$

**Purity:**
$$R_p(s_1, p) = R_p(s_2, p) \iff \forall d \in \text{deps}(p) : \text{content}_d(s_1) = \text{content}_d(s_2)$$

**No side effects:**
$$\text{exec}(R_p) \implies s' = s$$

## Verification

### Current Implementation (`src/04_propagation/PropagationEngine.jl:171-178`)

```julia
function register_passthrough_recompute!(state::MMSBState, target_page_id::PageID,
                                         source_page_id::PageID; transform=identity)
    register_recompute_fn!(state, target_page_id, function (st, _)
        source = get_page(st, source_page_id)
        source === nothing && throw(PageNotFoundError(...))
        return Vector{UInt8}(transform(read_page(source)))
    end)
end
```

### Purity Analysis

✅ **Pure**: Returns `Vector{UInt8}`, no state mutation  
✅ **No side effects**: Only reads via `get_page` and `read_page`  
✅ **Explicit deps**: Source page captured in closure  
✅ **Deterministic**: Same input → same output

### Contract Documentation

**Dependency declaration:**
```julia
page.metadata[:recompute_deps] :: Vector{PageID}
```

**Function signature:**
```julia
(state::MMSBState, page::Page) -> Vector{UInt8}
```

**Prohibited:**
- Global state access
- I/O operations
- Time-dependent values
- State mutation

## Conclusion

Current implementation satisfies purity contract. Ready for T1.1 (signature system) and T1.2 (validation).

**Next:** T1.1 will add epoch-based signature tracking to enable cache invalidation.
