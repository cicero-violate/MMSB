# T0.3: ID Scope Verification

**Status:** ✅ Documented  
**Date:** 2025-12-17

## Task

Verify and document ID uniqueness scope: per-state lifetime, reset on pooling.

## Mathematical Definition

$$\mathcal{I}_s = \text{ID space for state } s$$

**Uniqueness within state:**
$$\forall i \neq j : \text{ID}_{\text{page}}(i) \neq \text{ID}_{\text{page}}(j)$$

**Independence across states:**
$$s_1 \neq s_2 \implies \mathcal{I}_{s_1} \cap \mathcal{I}_{s_2} = \emptyset$$

## Current Implementation

### Monotonic Counters (`src/01_types/MMSBState.jl:56-57, 91-117`)

```julia
mutable struct MMSBState
    next_page_id::Ref{PageID}     # Starts at 1
    next_delta_id::Ref{DeltaID}   # Starts at 1
    lock::ReentrantLock
end

function allocate_page_id!(state::MMSBState)::PageID
    lock(state.lock) do
        id = state.next_page_id[]
        state.next_page_id[] = PageID(id + 1)
        return id
    end
end
```

✅ **Thread-safe**: Lock protects allocation  
✅ **Monotonic**: Always increments  
✅ **Per-state**: Each MMSBState has independent counters

## Determinism Invariant

**Replay requirement:**
$$\text{replay}(s_0, \Omega) \implies \text{same ID sequence}$$

**Conditions:**
1. Fixed initial state $s_0$
2. Deterministic operation order
3. No concurrent allocation (or deterministic lock order)

## Pool Reset (T3.2 future)

```julia
function reset!(state::MMSBState)
    state.next_page_id[] = PageID(1)    # Reset
    state.next_delta_id[] = DeltaID(1)  # Reset
    # ...
end
```

After reset: $\mathcal{I}_{s'}$ is fresh ID space.

## Conclusion

ID scope correctly implemented. IDs unique within state lifetime, reset on pool return ensures deterministic replay.

**Blocks:** T3.2 (reset implementation), T3.3 (pool determinism test)
