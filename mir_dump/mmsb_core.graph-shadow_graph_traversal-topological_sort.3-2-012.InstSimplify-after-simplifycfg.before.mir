// MIR for `graph::shadow_graph_traversal::topological_sort` before InstSimplify-after-simplifycfg

fn topological_sort(_1: &ShadowPageGraph) -> Vec<PageID> {
    debug graph => _1;
    let mut _0: std::vec::Vec<types::page::PageID>;
    let mut _2: std::vec::Vec<types::page::PageID>;
    let _5: ();
    let mut _6: std::collections::hash_map::Iter<'_, types::page::PageID, std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>>;
    let mut _7: std::collections::hash_map::Iter<'_, types::page::PageID, std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>>;
    let mut _8: &std::collections::HashMap<types::page::PageID, std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>>;
    let _9: &std::collections::HashMap<types::page::PageID, std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>>;
    let mut _10: &parking_lot::lock_api::RwLockReadGuard<'_, parking_lot::RawRwLock, std::collections::HashMap<types::page::PageID, std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>>>;
    let _11: parking_lot::lock_api::RwLockReadGuard<'_, parking_lot::RawRwLock, std::collections::HashMap<types::page::PageID, std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>>>;
    let mut _12: &parking_lot::lock_api::RwLock<parking_lot::RawRwLock, std::collections::HashMap<types::page::PageID, std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>>>;
    let mut _14: ();
    let _15: ();
    let mut _16: std::option::Option<(&types::page::PageID, &std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>)>;
    let mut _17: &mut std::collections::hash_map::Iter<'_, types::page::PageID, std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>>;
    let mut _18: &mut std::collections::hash_map::Iter<'_, types::page::PageID, std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>>;
    let mut _19: isize;
    let mut _20: !;
    let _23: std::option::Option<std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>>;
    let mut _24: &mut std::collections::HashMap<types::page::PageID, std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>>;
    let mut _25: types::page::PageID;
    let mut _26: std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>;
    let mut _27: &std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>;
    let _28: &mut i32;
    let mut _29: std::collections::hash_map::Entry<'_, types::page::PageID, i32>;
    let mut _30: &mut std::collections::HashMap<types::page::PageID, i32>;
    let mut _31: types::page::PageID;
    let mut _32: std::slice::Iter<'_, (types::page::PageID, graph::edge_types::EdgeType)>;
    let mut _33: std::slice::Iter<'_, (types::page::PageID, graph::edge_types::EdgeType)>;
    let mut _34: &[(types::page::PageID, graph::edge_types::EdgeType)];
    let _35: &[(types::page::PageID, graph::edge_types::EdgeType)];
    let mut _36: &std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>;
    let _38: ();
    let mut _39: std::option::Option<&(types::page::PageID, graph::edge_types::EdgeType)>;
    let mut _40: &mut std::slice::Iter<'_, (types::page::PageID, graph::edge_types::EdgeType)>;
    let mut _41: &mut std::slice::Iter<'_, (types::page::PageID, graph::edge_types::EdgeType)>;
    let mut _42: isize;
    let mut _43: !;
    let mut _45: &mut i32;
    let mut _46: std::collections::hash_map::Entry<'_, types::page::PageID, i32>;
    let mut _47: &mut std::collections::HashMap<types::page::PageID, i32>;
    let mut _48: types::page::PageID;
    let mut _49: (i32, bool);
    let mut _51: std::iter::FilterMap<std::collections::hash_map::Iter<'_, types::page::PageID, i32>, {closure@src/05_graph/shadow_graph_traversal.rs:24:21: 24:36}>;
    let mut _52: std::collections::hash_map::Iter<'_, types::page::PageID, i32>;
    let mut _53: &std::collections::HashMap<types::page::PageID, i32>;
    let mut _54: {closure@src/05_graph/shadow_graph_traversal.rs:24:21: 24:36};
    let _55: ();
    let mut _56: std::option::Option<types::page::PageID>;
    let mut _57: &mut std::collections::VecDeque<types::page::PageID>;
    let mut _58: isize;
    let _60: ();
    let mut _61: &mut std::vec::Vec<types::page::PageID>;
    let mut _62: types::page::PageID;
    let mut _63: std::option::Option<&std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>>;
    let mut _64: &std::collections::HashMap<types::page::PageID, std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>>;
    let mut _65: &types::page::PageID;
    let _66: &types::page::PageID;
    let mut _67: isize;
    let mut _69: std::slice::Iter<'_, (types::page::PageID, graph::edge_types::EdgeType)>;
    let mut _70: &std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>;
    let _72: ();
    let mut _73: std::option::Option<&(types::page::PageID, graph::edge_types::EdgeType)>;
    let mut _74: &mut std::slice::Iter<'_, (types::page::PageID, graph::edge_types::EdgeType)>;
    let mut _75: &mut std::slice::Iter<'_, (types::page::PageID, graph::edge_types::EdgeType)>;
    let mut _76: isize;
    let mut _77: !;
    let mut _79: std::option::Option<&mut i32>;
    let mut _80: &mut std::collections::HashMap<types::page::PageID, i32>;
    let mut _81: &types::page::PageID;
    let mut _82: isize;
    let mut _84: (i32, bool);
    let mut _85: bool;
    let mut _86: i32;
    let _87: ();
    let mut _88: &mut std::collections::VecDeque<types::page::PageID>;
    let mut _89: types::page::PageID;
    let mut _90: !;
    let _91: ();
    let mut _92: !;
    let mut _93: &(types::page::PageID, graph::edge_types::EdgeType);
    let mut _94: &(types::page::PageID, graph::edge_types::EdgeType);
    let mut _95: bool;
    scope 1 {
        debug result => _2;
        let mut _3: std::collections::HashMap<types::page::PageID, i32>;
        scope 2 {
            debug in_degree => _3;
            let mut _4: std::collections::HashMap<types::page::PageID, std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>>;
            scope 3 {
                debug adjacency => _4;
                let mut _13: std::collections::hash_map::Iter<'_, types::page::PageID, std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>>;
                let mut _50: std::collections::VecDeque<types::page::PageID>;
                scope 4 {
                    debug iter => _13;
                    let _21: &types::page::PageID;
                    let _22: &std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>;
                    scope 5 {
                        debug node => _21;
                        debug edges => _22;
                        let mut _37: std::slice::Iter<'_, (types::page::PageID, graph::edge_types::EdgeType)>;
                        scope 6 {
                            debug iter => _37;
                            let _44: &types::page::PageID;
                            scope 7 {
                                debug child => _44;
                            }
                        }
                    }
                }
                scope 8 {
                    debug queue => _50;
                    scope 9 {
                        debug node => _59;
                        let _59: types::page::PageID;
                        scope 10 {
                            debug children => _68;
                            let _68: &std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>;
                            let mut _71: std::slice::Iter<'_, (types::page::PageID, graph::edge_types::EdgeType)>;
                            scope 11 {
                                debug iter => _71;
                                let _78: &types::page::PageID;
                                scope 12 {
                                    debug child => _78;
                                    scope 13 {
                                        debug deg => _83;
                                        let _83: &mut i32;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _95 = const false;
        _95 = const true;
        _2 = Vec::<PageID>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = HashMap::<PageID, i32>::new() -> [return: bb2, unwind: bb54];
    }

    bb2: {
        _4 = HashMap::<PageID, Vec<(PageID, EdgeType)>>::new() -> [return: bb3, unwind: bb51];
    }

    bb3: {
        _12 = &((*_1).0: parking_lot::lock_api::RwLock<parking_lot::RawRwLock, std::collections::HashMap<types::page::PageID, std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>>>);
        _11 = parking_lot::lock_api::RwLock::<parking_lot::RawRwLock, HashMap<PageID, Vec<(PageID, EdgeType)>>>::read(move _12) -> [return: bb4, unwind: bb50];
    }

    bb4: {
        _10 = &_11;
        _9 = <parking_lot::lock_api::RwLockReadGuard<'_, parking_lot::RawRwLock, HashMap<PageID, Vec<(PageID, EdgeType)>>> as Deref>::deref(move _10) -> [return: bb5, unwind: bb49];
    }

    bb5: {
        _8 = copy _9;
        _7 = HashMap::<PageID, Vec<(PageID, EdgeType)>>::iter(move _8) -> [return: bb6, unwind: bb49];
    }

    bb6: {
        _6 = <std::collections::hash_map::Iter<'_, PageID, Vec<(PageID, EdgeType)>> as IntoIterator>::into_iter(move _7) -> [return: bb7, unwind: bb49];
    }

    bb7: {
        _13 = move _6;
        goto -> bb8;
    }

    bb8: {
        _18 = &mut _13;
        _17 = copy _18;
        _16 = <std::collections::hash_map::Iter<'_, PageID, Vec<(PageID, EdgeType)>> as Iterator>::next(move _17) -> [return: bb9, unwind: bb49];
    }

    bb9: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb12, 1: bb11, otherwise: bb10];
    }

    bb10: {
        unreachable;
    }

    bb11: {
        _21 = copy (((_16 as Some).0: (&types::page::PageID, &std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>)).0: &types::page::PageID);
        _22 = copy (((_16 as Some).0: (&types::page::PageID, &std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>)).1: &std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>);
        _24 = &mut _4;
        _25 = copy (*_21);
        _27 = copy _22;
        _26 = <Vec<(PageID, EdgeType)> as Clone>::clone(move _27) -> [return: bb13, unwind: bb49];
    }

    bb12: {
        drop(_11) -> [return: bb27, unwind: bb50];
    }

    bb13: {
        _23 = HashMap::<PageID, Vec<(PageID, EdgeType)>>::insert(move _24, move _25, move _26) -> [return: bb14, unwind: bb49];
    }

    bb14: {
        drop(_23) -> [return: bb15, unwind: bb49];
    }

    bb15: {
        _30 = &mut _3;
        _31 = copy (*_21);
        _29 = HashMap::<PageID, i32>::entry(move _30, move _31) -> [return: bb16, unwind: bb49];
    }

    bb16: {
        _28 = std::collections::hash_map::Entry::<'_, PageID, i32>::or_insert(move _29, const 0_i32) -> [return: bb17, unwind: bb49];
    }

    bb17: {
        _36 = copy _22;
        _35 = <Vec<(PageID, EdgeType)> as Deref>::deref(move _36) -> [return: bb18, unwind: bb49];
    }

    bb18: {
        _34 = copy _35;
        _33 = core::slice::<impl [(PageID, EdgeType)]>::iter(move _34) -> [return: bb19, unwind: bb49];
    }

    bb19: {
        _32 = <std::slice::Iter<'_, (PageID, EdgeType)> as IntoIterator>::into_iter(move _33) -> [return: bb20, unwind: bb49];
    }

    bb20: {
        _37 = move _32;
        goto -> bb21;
    }

    bb21: {
        _41 = &mut _37;
        _40 = copy _41;
        _39 = <std::slice::Iter<'_, (PageID, EdgeType)> as Iterator>::next(move _40) -> [return: bb22, unwind: bb49];
    }

    bb22: {
        _42 = discriminant(_39);
        switchInt(move _42) -> [0: bb8, 1: bb23, otherwise: bb10];
    }

    bb23: {
        _93 = copy ((_39 as Some).0: &(types::page::PageID, graph::edge_types::EdgeType));
        _44 = &((*_93).0: types::page::PageID);
        _47 = &mut _3;
        _48 = copy (*_44);
        _46 = HashMap::<PageID, i32>::entry(move _47, move _48) -> [return: bb24, unwind: bb49];
    }

    bb24: {
        _45 = std::collections::hash_map::Entry::<'_, PageID, i32>::or_insert(move _46, const 0_i32) -> [return: bb25, unwind: bb49];
    }

    bb25: {
        _49 = AddWithOverflow(copy (*_45), const 1_i32);
        assert(!move (_49.1: bool), "attempt to compute `{} + {}`, which would overflow", copy (*_45), const 1_i32) -> [success: bb26, unwind: bb49];
    }

    bb26: {
        (*_45) = move (_49.0: i32);
        goto -> bb21;
    }

    bb27: {
        _53 = &_3;
        _52 = HashMap::<PageID, i32>::iter(move _53) -> [return: bb28, unwind: bb50];
    }

    bb28: {
        _51 = <std::collections::hash_map::Iter<'_, PageID, i32> as Iterator>::filter_map::<PageID, {closure@src/05_graph/shadow_graph_traversal.rs:24:21: 24:36}>(move _52, const ZeroSized: {closure@src/05_graph/shadow_graph_traversal.rs:24:21: 24:36}) -> [return: bb29, unwind: bb50];
    }

    bb29: {
        _50 = <FilterMap<std::collections::hash_map::Iter<'_, PageID, i32>, {closure@src/05_graph/shadow_graph_traversal.rs:24:21: 24:36}> as Iterator>::collect::<VecDeque<PageID>>(move _51) -> [return: bb30, unwind: bb50];
    }

    bb30: {
        _57 = &mut _50;
        _56 = VecDeque::<PageID>::pop_front(move _57) -> [return: bb31, unwind: bb48];
    }

    bb31: {
        _58 = discriminant(_56);
        switchInt(move _58) -> [1: bb32, 0: bb44, otherwise: bb10];
    }

    bb32: {
        _59 = copy ((_56 as Some).0: types::page::PageID);
        _61 = &mut _2;
        _62 = copy _59;
        _60 = Vec::<PageID>::push(move _61, move _62) -> [return: bb33, unwind: bb48];
    }

    bb33: {
        _64 = &_4;
        _66 = &_59;
        _65 = copy _66;
        _63 = HashMap::<PageID, Vec<(PageID, EdgeType)>>::get::<PageID>(move _64, move _65) -> [return: bb34, unwind: bb48];
    }

    bb34: {
        _67 = discriminant(_63);
        switchInt(move _67) -> [1: bb35, 0: bb30, otherwise: bb10];
    }

    bb35: {
        _68 = copy ((_63 as Some).0: &std::vec::Vec<(types::page::PageID, graph::edge_types::EdgeType)>);
        _70 = copy _68;
        _69 = <&Vec<(PageID, EdgeType)> as IntoIterator>::into_iter(move _70) -> [return: bb36, unwind: bb48];
    }

    bb36: {
        _71 = move _69;
        goto -> bb37;
    }

    bb37: {
        _75 = &mut _71;
        _74 = copy _75;
        _73 = <std::slice::Iter<'_, (PageID, EdgeType)> as Iterator>::next(move _74) -> [return: bb38, unwind: bb48];
    }

    bb38: {
        _76 = discriminant(_73);
        switchInt(move _76) -> [0: bb30, 1: bb39, otherwise: bb10];
    }

    bb39: {
        _94 = copy ((_73 as Some).0: &(types::page::PageID, graph::edge_types::EdgeType));
        _78 = &((*_94).0: types::page::PageID);
        _80 = &mut _3;
        _81 = copy _78;
        _79 = HashMap::<PageID, i32>::get_mut::<PageID>(move _80, move _81) -> [return: bb40, unwind: bb48];
    }

    bb40: {
        _82 = discriminant(_79);
        switchInt(move _82) -> [1: bb41, 0: bb37, otherwise: bb10];
    }

    bb41: {
        _83 = move ((_79 as Some).0: &mut i32);
        _84 = SubWithOverflow(copy (*_83), const 1_i32);
        assert(!move (_84.1: bool), "attempt to compute `{} - {}`, which would overflow", copy (*_83), const 1_i32) -> [success: bb42, unwind: bb48];
    }

    bb42: {
        (*_83) = move (_84.0: i32);
        _86 = copy (*_83);
        _85 = Eq(move _86, const 0_i32);
        switchInt(move _85) -> [0: bb37, otherwise: bb43];
    }

    bb43: {
        _88 = &mut _50;
        _89 = copy (*_78);
        _87 = VecDeque::<PageID>::push_back(move _88, move _89) -> [return: bb37, unwind: bb48];
    }

    bb44: {
        _95 = const false;
        _0 = move _2;
        drop(_50) -> [return: bb45, unwind: bb50];
    }

    bb45: {
        drop(_4) -> [return: bb46, unwind: bb51];
    }

    bb46: {
        drop(_3) -> [return: bb47, unwind: bb54];
    }

    bb47: {
        _95 = const false;
        return;
    }

    bb48 (cleanup): {
        drop(_50) -> [return: bb50, unwind terminate(cleanup)];
    }

    bb49 (cleanup): {
        drop(_11) -> [return: bb50, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        drop(_4) -> [return: bb51, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        drop(_3) -> [return: bb54, unwind terminate(cleanup)];
    }

    bb52 (cleanup): {
        resume;
    }

    bb53 (cleanup): {
        drop(_2) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        switchInt(copy _95) -> [0: bb52, otherwise: bb53];
    }
}
